/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/indirect3d/color.ts":
/*!*********************************!*\
  !*** ./src/indirect3d/color.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XRGB\": () => (/* binding */ XRGB),\n/* harmony export */   \"ARGB\": () => (/* binding */ ARGB),\n/* harmony export */   \"I3DXAlphaBlend\": () => (/* binding */ I3DXAlphaBlend),\n/* harmony export */   \"ColorToLab\": () => (/* binding */ ColorToLab),\n/* harmony export */   \"LabToColor\": () => (/* binding */ LabToColor)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/indirect3d/utils.ts\");\n\nfunction XRGB(r, g, b) {\n    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.pack)(255, r, g, b);\n}\nfunction ARGB(a, r, g, b) {\n    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.pack)(a, r, g, b);\n}\nfunction I3DXAlphaBlend(bg, src) {\n    const sa = src >>> 24;\n    const ba = bg >>> 24;\n    // src is transparent.\n    if (sa == 0) {\n        return bg;\n    }\n    // bg is transparent.\n    if (ba == 0)\n        return src;\n    let [a0, r0, g0, b0] = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.unpack)(bg);\n    let [a1, r1, g1, b1] = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.unpack)(src);\n    a0 = a0 / 255;\n    a1 = a1 / 255;\n    let a = a0 + a1 - a0 * a1;\n    const r = Math.round((r0 * a0 + r1 * (1 - a0) * a1) / a);\n    const g = Math.round((g0 * a0 + g1 * (1 - a0) * a1) / a);\n    const b = Math.round((b0 * a0 + b1 * (1 - a0) * a1) / a);\n    a = Math.min(255, Math.round(a * 255));\n    return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.pack)(a, r, g, b);\n}\nfunction ColorToLab(color) {\n    const [_, r, g, b] = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.unpack)(color);\n    const [X, Y, Z] = RGBToXYZ(r, g, b);\n    return XYZToLab(X, Y, Z);\n}\nfunction LabToColor(L, a, b) {\n    const [X, Y, Z] = LabToXYZ(L, a, b);\n    const [rc, gc, bc] = XYZToRGB(X, Y, Z);\n    return XRGB(rc, gc, bc);\n}\n// These conversions come from http://www.easyrgb.com/en/math.php\nfunction RGBToXYZ(r, g, b) {\n    let rf = r / 255;\n    let gf = g / 255;\n    let bf = b / 255;\n    if (rf > 0.04045) {\n        rf = Math.pow(((rf + 0.055) / 1.055), 2.4);\n    }\n    else {\n        rf = rf / 12.92;\n    }\n    rf *= 100;\n    if (gf > 0.04045) {\n        gf = Math.pow(((gf + 0.055) / 1.055), 2.4);\n    }\n    else {\n        gf = gf / 12.92;\n    }\n    gf *= 100;\n    if (bf > 0.04045) {\n        bf = Math.pow(((bf + 0.055) / 1.055), 2.4);\n    }\n    else {\n        bf = bf / 12.92;\n    }\n    bf *= 100;\n    return [\n        rf * 0.4124 + gf * 0.3576 + bf * 0.1805,\n        rf * 0.2126 + gf * 0.7152 + bf * 0.0722,\n        rf * 0.0193 + gf * 0.1192 + bf * 0.9505,\n    ];\n}\nfunction XYZToRGB(x, y, z) {\n    const vx = x / 100;\n    const vy = y / 100;\n    const vz = z / 100;\n    let vr = vx * 3.2406 + vy * -1.5372 + vz * -0.4986;\n    let vg = vx * -0.9689 + vy * 1.8758 + vz * 0.0415;\n    let vb = vx * 0.0557 + vy * -0.2040 + vz * 1.0570;\n    if (vr > 0.0031308) {\n        vr = 1.055 * (Math.pow(vr, (1 / 2.4))) - 0.55;\n    }\n    else {\n        vr = 12.92 * vr;\n    }\n    if (vg > 0.0031308) {\n        vg = 1.055 * (Math.pow(vg, (1 / 2.4))) - 0.55;\n    }\n    else {\n        vg = 12.92 * vg;\n    }\n    if (vb > 0.0031308) {\n        vb = 1.055 * (Math.pow(vb, (1 / 2.4))) - 0.55;\n    }\n    else {\n        vb = 12.92 * vb;\n    }\n    return [\n        Math.round(vr * 255),\n        Math.round(vg * 255),\n        Math.round(vb * 255),\n    ];\n}\n// Reference 2Â° (CIE 1931) / D65\nconst RefX = 95.047;\nconst RefY = 100;\nconst RefZ = 108.883;\nfunction XYZToLab(x, y, z) {\n    let vx = x / RefX;\n    let vy = y / RefY;\n    let vz = z / RefZ;\n    if (vx > 0.008856) {\n        vx = Math.pow(vx, (1 / 3));\n    }\n    else {\n        vx = (7.787 * vx) + (16 / 116);\n    }\n    if (vy > 0.008856) {\n        vy = Math.pow(vy, (1 / 3));\n    }\n    else {\n        vy = (7.787 * vy) + (16 / 116);\n    }\n    if (vz > 0.008856) {\n        vz = Math.pow(vz, (1 / 3));\n    }\n    else {\n        vz = (7.787 * vz) + (16 / 116);\n    }\n    return [\n        (116 * vy) - 16,\n        500 * (vx - vy),\n        200 * (vy - vz),\n    ];\n}\nfunction LabToXYZ(L, a, b) {\n    let vy = (L + 16) / 116;\n    let vx = a / 500 - vy;\n    let vz = vy - b / 200;\n    if (Math.pow(vx, 3) > 0.008856) {\n        vx = Math.pow(vx, 3);\n    }\n    else {\n        vx = (vx - 16 / 116) / 7.787;\n    }\n    if (Math.pow(vy, 3) > 0.008856) {\n        vy = Math.pow(vy, 3);\n    }\n    else {\n        vy = (vy - 16 / 116) / 7.787;\n    }\n    if (Math.pow(vz, 3) > 0.008856) {\n        vz = Math.pow(vz, 3);\n    }\n    else {\n        vz = (vz - 16 / 116) / 7.787;\n    }\n    return [\n        vx * RefX,\n        vy * RefY,\n        vz * RefZ,\n    ];\n}\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/color.ts?");

/***/ }),

/***/ "./src/indirect3d/device.ts":
/*!**********************************!*\
  !*** ./src/indirect3d/device.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"I3DTS_WORLD\": () => (/* binding */ I3DTS_WORLD),\n/* harmony export */   \"I3DTS_VIEW\": () => (/* binding */ I3DTS_VIEW),\n/* harmony export */   \"I3DTS_PROJECTION\": () => (/* binding */ I3DTS_PROJECTION),\n/* harmony export */   \"I3DPT_POINTLIST\": () => (/* binding */ I3DPT_POINTLIST),\n/* harmony export */   \"I3DPT_LINELIST\": () => (/* binding */ I3DPT_LINELIST),\n/* harmony export */   \"I3DPT_LINESTRIP\": () => (/* binding */ I3DPT_LINESTRIP),\n/* harmony export */   \"I3DPT_TRIANGLELIST\": () => (/* binding */ I3DPT_TRIANGLELIST),\n/* harmony export */   \"I3DPT_TRIANGLESTRIP\": () => (/* binding */ I3DPT_TRIANGLESTRIP),\n/* harmony export */   \"I3DPT_TRIANGLEFAN\": () => (/* binding */ I3DPT_TRIANGLEFAN),\n/* harmony export */   \"I3DXDevice\": () => (/* binding */ I3DXDevice)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/indirect3d/utils.ts\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ \"./src/indirect3d/color.ts\");\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./matrix */ \"./src/indirect3d/matrix.ts\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry */ \"./src/indirect3d/geometry.ts\");\n\n\n\n\nconst I3DTS_WORLD = 'world';\nconst I3DTS_VIEW = 'view';\nconst I3DTS_PROJECTION = 'projection';\nconst I3DPT_POINTLIST = 1;\nconst I3DPT_LINELIST = 2;\nconst I3DPT_LINESTRIP = 3;\nconst I3DPT_TRIANGLELIST = 4;\nconst I3DPT_TRIANGLESTRIP = 5;\nconst I3DPT_TRIANGLEFAN = 6;\nclass I3DXDevice {\n    constructor(container, WIDTH, HEIGHT) {\n        this.WIDTH = WIDTH;\n        this.HWIDTH = WIDTH / 2;\n        this.HEIGHT = HEIGHT;\n        this.HHEIGHT = HEIGHT / 2;\n        this._canvas = document.createElement('canvas');\n        this._canvas.width = WIDTH;\n        this._canvas.height = HEIGHT;\n        container.appendChild(this._canvas);\n        this._ctx = this._canvas.getContext('2d');\n        this._backBuffer = this._ctx.createImageData(WIDTH, HEIGHT);\n        const defaultView = (0,_geometry__WEBPACK_IMPORTED_MODULE_3__.I3DXMatrixLookAtLH)((0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXVector3)(0.0, 0.0, 10.0), (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXVector3)(0.0, 0.0, 0.0), (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXVector3)(0.0, 1.0, 0.0));\n        const defaultProjection = (0,_geometry__WEBPACK_IMPORTED_MODULE_3__.I3DXMatrixPerspectiveFovLH)((0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXToRadian)(45), WIDTH / HEIGHT, 1, 100);\n        this._transforms = {\n            [I3DTS_WORLD]: (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixIdentity)(4),\n            [I3DTS_VIEW]: defaultView,\n            [I3DTS_PROJECTION]: defaultProjection,\n        };\n        this._transformsCache = {\n            [I3DTS_WORLD]: false,\n            [I3DTS_VIEW]: false,\n            [I3DTS_PROJECTION]: false,\n        };\n        const bufferLength = this.WIDTH * this.HEIGHT;\n        this._zbufferData = new Int32Array(bufferLength);\n        this._zbufferDepth = new Float32Array(bufferLength);\n    }\n    SetTransform(type, matrix) {\n        this._transforms[type] = matrix;\n        this._transformsCache[type] = true;\n    }\n    BeginScene() {\n        this.ZBufferClear();\n        this._backBuffer = this._ctx.createImageData(this.WIDTH, this.HEIGHT);\n    }\n    DrawPrimitive(mode, list) {\n        let transform;\n        transform = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixMultiply)(this._transforms[I3DTS_VIEW], this._transforms[I3DTS_PROJECTION]);\n        transform = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixMultiply)(this._transforms[I3DTS_WORLD], transform);\n        switch (mode) {\n            case I3DPT_POINTLIST:\n                for (let i = 0; i < list.length; i++) {\n                    const f = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixMultiply)(transform, list[i].coordinates);\n                    const bx = f.data[0] / f.data[3];\n                    const by = f.data[1] / f.data[3];\n                    const bz = f.data[2] / f.data[3];\n                    // If this is in the field of view\n                    if (Math.abs(bx) <= 1 &&\n                        Math.abs(by) <= 1 &&\n                        Math.abs(bz) <= 1) {\n                        const sx = Math.round((1 - bx) * this.HWIDTH);\n                        const sy = Math.round((1 - by) * this.HHEIGHT);\n                        this.ZBufferSet(sx, sy, list[i].color, bz);\n                    }\n                }\n                break;\n            case I3DPT_LINELIST:\n            case I3DPT_LINESTRIP:\n                for (let i = 0; i < list.length - 1; i++) {\n                    const f0 = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixMultiply)(transform, list[i].coordinates);\n                    const f1 = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixMultiply)(transform, list[i + 1].coordinates);\n                    const bx0 = f0.data[0] / f0.data[3];\n                    const by0 = f0.data[1] / f0.data[3];\n                    const bz0 = f0.data[2] / f0.data[3];\n                    const bx1 = f1.data[0] / f1.data[3];\n                    const by1 = f1.data[1] / f1.data[3];\n                    const bz1 = f1.data[2] / f1.data[3];\n                    // Given a distance from 0 to 1 along a line segment\n                    // between point f0 and point f1, return the appropriate\n                    // color.\n                    const [a0, r0, g0, b0] = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.unpack)(list[i].color);\n                    const [a1, r1, g1, b1] = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.unpack)(list[i + 1].color);\n                    const da = a1 - a0;\n                    const dr = r1 - r0;\n                    const dg = g1 - g0;\n                    const db = b1 - b0;\n                    const color = (distance) => {\n                        return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.pack)(Math.round(da * distance + a0), Math.round(dr * distance + r0), Math.round(dg * distance + g0), Math.round(db * distance + b0));\n                    };\n                    // Given a distance from 0 to 1 along a line segment\n                    // between point f0 and point f1, return a 3D, transformed\n                    // position.\n                    const dx = bx1 - bx0;\n                    const dy = by1 - by0;\n                    const dz = bz1 - bz0;\n                    const pos = (distance) => {\n                        return [\n                            dx * distance + bx0,\n                            dy * distance + by0,\n                            dz * distance + bz0,\n                        ];\n                    };\n                    const sx0 = Math.round((1 - bx0) * this.HWIDTH);\n                    const sx1 = Math.round((1 - bx1) * this.HWIDTH);\n                    const dsx = Math.abs(sx1 - sx0);\n                    for (let j = 0; j <= dsx; j++) {\n                        const dist = j / dsx;\n                        const [x, y, z] = pos(dist);\n                        const c = color(dist);\n                        if (Math.abs(x) < 1 &&\n                            Math.abs(y) < 1 &&\n                            Math.abs(z) < 1) {\n                            const sx = Math.round((1 - x) * this.HWIDTH);\n                            const sy = Math.round((1 - y) * this.HHEIGHT);\n                            this.ZBufferSet(sx, sy, c, z);\n                        }\n                    }\n                    if (mode === I3DPT_LINELIST) {\n                        // Disconnect the lines by moving along the list\n                        i++;\n                    }\n                }\n                break;\n            case I3DPT_TRIANGLELIST:\n                for (let i = 0; i < list.length - 2; i++) {\n                    const p = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixMultiply)(transform, list[i].coordinates);\n                    const q = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixMultiply)(transform, list[i + 1].coordinates);\n                    const r = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixMultiply)(transform, list[i + 2].coordinates);\n                    const P = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXVector3)(p.data[0] / p.data[3], p.data[1] / p.data[3], p.data[2] / p.data[3]);\n                    const Q = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXVector3)(q.data[0] / q.data[3], q.data[1] / q.data[3], q.data[2] / q.data[3]);\n                    const R = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXVector3)(r.data[0] / r.data[3], r.data[1] / r.data[3], r.data[2] / r.data[3]);\n                    const N = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXVectorCross)((0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixSubtract)(Q, P), (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixSubtract)(R, P));\n                    // Scaled coordinates\n                    const Psx = Math.round((1 - P.data[0]) * this.HWIDTH);\n                    const Psy = Math.round((1 - P.data[1]) * this.HHEIGHT);\n                    const Qsx = Math.round((1 - Q.data[0]) * this.HWIDTH);\n                    const Qsy = Math.round((1 - Q.data[1]) * this.HHEIGHT);\n                    const Rsx = Math.round((1 - R.data[0]) * this.HWIDTH);\n                    const Rsy = Math.round((1 - R.data[1]) * this.HHEIGHT);\n                    // Corners of a boundins square\n                    const Tp = Math.min(Psy, Qsy, Rsy);\n                    const Bp = Math.max(Psy, Qsy, Rsy);\n                    const Lp = Math.min(Psx, Qsx, Rsx);\n                    const Rp = Math.max(Psx, Qsx, Rsx);\n                    const dx = Bp - Tp; // vertical span\n                    const dy = Rp - Lp; // horizontal span\n                    const [Pa, Pr, Pg, Pb] = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.unpack)(list[i].color);\n                    const PLab = (0,_color__WEBPACK_IMPORTED_MODULE_1__.ColorToLab)(list[i].color);\n                    const [Qa, Qr, Qg, Qb] = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.unpack)(list[i + 1].color);\n                    const QLab = (0,_color__WEBPACK_IMPORTED_MODULE_1__.ColorToLab)(list[i + 1].color);\n                    const [Ra, Rr, Rg, Rb] = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.unpack)(list[i + 2].color);\n                    const RLab = (0,_color__WEBPACK_IMPORTED_MODULE_1__.ColorToLab)(list[i + 2].color);\n                    for (let y = Tp; y <= Bp && y <= this.HEIGHT; y++) {\n                        for (let x = Lp; x <= Rp && x <= this.WIDTH; x++) {\n                            // Determine if this point within the square is within the triangle\n                            const pq = (y > ((Qsy - Psy) / (Qsx - Psx) * (x - Psx) + Psy));\n                            const pr = (y < ((Rsy - Psy) / (Rsx - Psx) * (x - Psx) + Psy));\n                            const qr = (y > ((Rsy - Qsy) / (Rsx - Qsx) * (x - Qsx) + Qsy));\n                            // Point is on the right side of all 3 lines\n                            if (pq && pr && qr) {\n                                const [Wp, Wq, Wr] = (0,_geometry__WEBPACK_IMPORTED_MODULE_3__.I3DXBarycentricCoords)(x, y, Psx, Psy, Qsx, Qsy, Rsx, Rsy);\n                                const z = P.data[2] * Wp + Q.data[2] * Wq + R.data[2] * Wr;\n                                const L = PLab[0] * Wp + QLab[0] * Wq + RLab[0] * Wr;\n                                const a = PLab[1] * Wp + QLab[1] * Wq + RLab[1] * Wr;\n                                const b = PLab[2] * Wp + QLab[2] * Wq + RLab[2] * Wr;\n                                const [_, vr, vg, vb] = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.unpack)((0,_color__WEBPACK_IMPORTED_MODULE_1__.LabToColor)(L, a, b));\n                                // console.log('Lab', [L, a, b]);\n                                const c = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.pack)(Pa * Wp + Qa * Wq + Ra * Wr, Pr * Wp + Qr * Wq + Rr * Wr, Pg * Wp + Qg * Wq + Rg * Wr, Pb * Wp + Qb * Wq + Rb * Wr);\n                                this.ZBufferSet(x, y, c, z);\n                            }\n                        }\n                    }\n                }\n                break;\n        }\n    }\n    EndScene() {\n        const max = this.WIDTH * this.HEIGHT * 4;\n        for (let i = 0; i < max;) {\n            const [a, r, g, b] = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.unpack)(this._zbufferData[i / 4]);\n            this._backBuffer.data[i++] = r;\n            this._backBuffer.data[i++] = g;\n            this._backBuffer.data[i++] = b;\n            this._backBuffer.data[i++] = a;\n        }\n    }\n    Present() {\n        this._ctx.putImageData(this._backBuffer, 0, 0);\n    }\n    ZBufferSet(x, y, color, depth) {\n        const idx = this.WIDTH * (y - 1) + x;\n        const zdepth = this._zbufferDepth[idx];\n        const zcolor = this._zbufferData[idx];\n        depth = depth - 1; // Why this?\n        // Current pixel is solid and closer\n        const [za] = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.unpack)(zcolor);\n        if (za >= 100 && zdepth < depth) {\n            return;\n        }\n        // New pixel is solid, or no current color\n        const [a] = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.unpack)(color);\n        if (a >= 100 || za === 0) {\n            this._zbufferData[idx] = color;\n            this._zbufferDepth[idx] = depth;\n            return;\n        }\n        // Nothing solid, blend 'em\n        this._zbufferData[idx] = (0,_color__WEBPACK_IMPORTED_MODULE_1__.I3DXAlphaBlend)(zcolor, color);\n        // Which is closer\n        if (depth < zdepth) {\n            this._zbufferDepth[idx] = depth;\n        }\n    }\n    ZBufferClear() {\n        const bufferLength = this.WIDTH * this.HEIGHT;\n        this._zbufferData = new Int32Array(bufferLength);\n        this._zbufferDepth = new Float32Array(bufferLength);\n    }\n}\n;\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/device.ts?");

/***/ }),

/***/ "./src/indirect3d/geometry.ts":
/*!************************************!*\
  !*** ./src/indirect3d/geometry.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"I3DXVertex\": () => (/* binding */ I3DXVertex),\n/* harmony export */   \"I3DXMatrixLookAtLH\": () => (/* binding */ I3DXMatrixLookAtLH),\n/* harmony export */   \"I3DXMatrixPerspectiveFovLH\": () => (/* binding */ I3DXMatrixPerspectiveFovLH),\n/* harmony export */   \"I3DXBarycentricCoords\": () => (/* binding */ I3DXBarycentricCoords)\n/* harmony export */ });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ \"./src/indirect3d/matrix.ts\");\n\nclass I3DXVertex {\n    constructor(x, y, z, color) {\n        const c = (0,_matrix__WEBPACK_IMPORTED_MODULE_0__.I3DXVector)(4);\n        c.data[0] = x;\n        c.data[1] = y;\n        c.data[2] = z;\n        c.data[3] = 1;\n        this.coordinates = c;\n        this.color = color;\n    }\n}\nfunction I3DXMatrixLookAtLH(pEye, pAt, pUp) {\n    const matrix = (0,_matrix__WEBPACK_IMPORTED_MODULE_0__.I3DXMatrixIdentity)(4);\n    const zaxis = (0,_matrix__WEBPACK_IMPORTED_MODULE_0__.I3DXVectorUnit)((0,_matrix__WEBPACK_IMPORTED_MODULE_0__.I3DXMatrixSubtract)(pAt, pEye));\n    const xaxis = (0,_matrix__WEBPACK_IMPORTED_MODULE_0__.I3DXVectorUnit)((0,_matrix__WEBPACK_IMPORTED_MODULE_0__.I3DXVectorCross)(pUp, zaxis));\n    const yaxis = (0,_matrix__WEBPACK_IMPORTED_MODULE_0__.I3DXVectorCross)(zaxis, xaxis);\n    matrix.set(0, 0, xaxis.data[0]);\n    matrix.set(1, 0, xaxis.data[1]);\n    matrix.set(2, 0, xaxis.data[2]);\n    matrix.set(3, 0, -(0,_matrix__WEBPACK_IMPORTED_MODULE_0__.I3DXVectorDot)(xaxis, pEye));\n    matrix.set(0, 1, yaxis.data[0]);\n    matrix.set(1, 1, yaxis.data[1]);\n    matrix.set(2, 1, yaxis.data[2]);\n    matrix.set(3, 1, -(0,_matrix__WEBPACK_IMPORTED_MODULE_0__.I3DXVectorDot)(yaxis, pEye));\n    matrix.set(0, 2, zaxis.data[0]);\n    matrix.set(1, 2, zaxis.data[1]);\n    matrix.set(2, 2, zaxis.data[2]);\n    matrix.set(3, 2, -(0,_matrix__WEBPACK_IMPORTED_MODULE_0__.I3DXVectorDot)(zaxis, pEye));\n    return matrix;\n}\nfunction I3DXMatrixPerspectiveFovLH(fovy, aspect, zn, zf) {\n    var y = 1 / Math.tan(fovy / 2);\n    const x = y / aspect;\n    const matrix = new _matrix__WEBPACK_IMPORTED_MODULE_0__.I3DXMatrix(4, 4);\n    matrix.set(0, 0, x);\n    matrix.set(1, 1, y);\n    matrix.set(2, 2, zf / (zf - zn));\n    matrix.set(2, 3, 1);\n    matrix.set(3, 2, -zn * zf / (zf - zn));\n    return matrix;\n}\nfunction I3DXBarycentricCoords(x, y, x1, y1, x2, y2, x3, y3) {\n    const y2y3 = y2 - y3;\n    const x3x2 = x3 - x2;\n    const x1x3 = x1 - x3;\n    const y1y3 = y1 - y3;\n    const y3y1 = y3 - y1;\n    const xx3 = x - x3;\n    const yy3 = y - y3;\n    const d = y2y3 * x1x3 + x3x2 * y1y3;\n    const w1 = (y2y3 * xx3 + x3x2 * yy3) / d;\n    const w2 = (y3y1 * xx3 + x1x3 * yy3) / d;\n    return [w1, w2, 1 - w1 - w2];\n}\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/geometry.ts?");

/***/ }),

/***/ "./src/indirect3d/index.ts":
/*!*********************************!*\
  !*** ./src/indirect3d/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ARGB\": () => (/* reexport safe */ _color__WEBPACK_IMPORTED_MODULE_0__.ARGB),\n/* harmony export */   \"ColorToLab\": () => (/* reexport safe */ _color__WEBPACK_IMPORTED_MODULE_0__.ColorToLab),\n/* harmony export */   \"I3DXAlphaBlend\": () => (/* reexport safe */ _color__WEBPACK_IMPORTED_MODULE_0__.I3DXAlphaBlend),\n/* harmony export */   \"LabToColor\": () => (/* reexport safe */ _color__WEBPACK_IMPORTED_MODULE_0__.LabToColor),\n/* harmony export */   \"XRGB\": () => (/* reexport safe */ _color__WEBPACK_IMPORTED_MODULE_0__.XRGB),\n/* harmony export */   \"I3DPT_LINELIST\": () => (/* reexport safe */ _device__WEBPACK_IMPORTED_MODULE_1__.I3DPT_LINELIST),\n/* harmony export */   \"I3DPT_LINESTRIP\": () => (/* reexport safe */ _device__WEBPACK_IMPORTED_MODULE_1__.I3DPT_LINESTRIP),\n/* harmony export */   \"I3DPT_POINTLIST\": () => (/* reexport safe */ _device__WEBPACK_IMPORTED_MODULE_1__.I3DPT_POINTLIST),\n/* harmony export */   \"I3DPT_TRIANGLEFAN\": () => (/* reexport safe */ _device__WEBPACK_IMPORTED_MODULE_1__.I3DPT_TRIANGLEFAN),\n/* harmony export */   \"I3DPT_TRIANGLELIST\": () => (/* reexport safe */ _device__WEBPACK_IMPORTED_MODULE_1__.I3DPT_TRIANGLELIST),\n/* harmony export */   \"I3DPT_TRIANGLESTRIP\": () => (/* reexport safe */ _device__WEBPACK_IMPORTED_MODULE_1__.I3DPT_TRIANGLESTRIP),\n/* harmony export */   \"I3DTS_PROJECTION\": () => (/* reexport safe */ _device__WEBPACK_IMPORTED_MODULE_1__.I3DTS_PROJECTION),\n/* harmony export */   \"I3DTS_VIEW\": () => (/* reexport safe */ _device__WEBPACK_IMPORTED_MODULE_1__.I3DTS_VIEW),\n/* harmony export */   \"I3DTS_WORLD\": () => (/* reexport safe */ _device__WEBPACK_IMPORTED_MODULE_1__.I3DTS_WORLD),\n/* harmony export */   \"I3DXDevice\": () => (/* reexport safe */ _device__WEBPACK_IMPORTED_MODULE_1__.I3DXDevice),\n/* harmony export */   \"I3DXBarycentricCoords\": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_2__.I3DXBarycentricCoords),\n/* harmony export */   \"I3DXMatrixLookAtLH\": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixLookAtLH),\n/* harmony export */   \"I3DXMatrixPerspectiveFovLH\": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_2__.I3DXMatrixPerspectiveFovLH),\n/* harmony export */   \"I3DXVertex\": () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_2__.I3DXVertex),\n/* harmony export */   \"I3DXMatrix\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXMatrix),\n/* harmony export */   \"I3DXMatrixAdd\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXMatrixAdd),\n/* harmony export */   \"I3DXMatrixIdentity\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXMatrixIdentity),\n/* harmony export */   \"I3DXMatrixMultiply\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXMatrixMultiply),\n/* harmony export */   \"I3DXMatrixScale\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXMatrixScale),\n/* harmony export */   \"I3DXMatrixSubtract\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXMatrixSubtract),\n/* harmony export */   \"I3DXMatrixTranspose\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXMatrixTranspose),\n/* harmony export */   \"I3DXRotateXMatrix\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXRotateXMatrix),\n/* harmony export */   \"I3DXRotateYMatrix\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXRotateYMatrix),\n/* harmony export */   \"I3DXRotateZMatrix\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXRotateZMatrix),\n/* harmony export */   \"I3DXScaleMatrix\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXScaleMatrix),\n/* harmony export */   \"I3DXToRadian\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXToRadian),\n/* harmony export */   \"I3DXTranslateMatrix\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXTranslateMatrix),\n/* harmony export */   \"I3DXVector\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXVector),\n/* harmony export */   \"I3DXVector3\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXVector3),\n/* harmony export */   \"I3DXVectorCross\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXVectorCross),\n/* harmony export */   \"I3DXVectorDot\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXVectorDot),\n/* harmony export */   \"I3DXVectorLength\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXVectorLength),\n/* harmony export */   \"I3DXVectorUnit\": () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_3__.I3DXVectorUnit)\n/* harmony export */ });\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ \"./src/indirect3d/color.ts\");\n/* harmony import */ var _device__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./device */ \"./src/indirect3d/device.ts\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry */ \"./src/indirect3d/geometry.ts\");\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matrix */ \"./src/indirect3d/matrix.ts\");\n\n\n\n\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/index.ts?");

/***/ }),

/***/ "./src/indirect3d/matrix.ts":
/*!**********************************!*\
  !*** ./src/indirect3d/matrix.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"I3DXMatrix\": () => (/* binding */ I3DXMatrix),\n/* harmony export */   \"I3DXMatrixIdentity\": () => (/* binding */ I3DXMatrixIdentity),\n/* harmony export */   \"I3DXTranslateMatrix\": () => (/* binding */ I3DXTranslateMatrix),\n/* harmony export */   \"I3DXScaleMatrix\": () => (/* binding */ I3DXScaleMatrix),\n/* harmony export */   \"I3DXToRadian\": () => (/* binding */ I3DXToRadian),\n/* harmony export */   \"I3DXRotateXMatrix\": () => (/* binding */ I3DXRotateXMatrix),\n/* harmony export */   \"I3DXRotateYMatrix\": () => (/* binding */ I3DXRotateYMatrix),\n/* harmony export */   \"I3DXRotateZMatrix\": () => (/* binding */ I3DXRotateZMatrix),\n/* harmony export */   \"I3DXMatrixTranspose\": () => (/* binding */ I3DXMatrixTranspose),\n/* harmony export */   \"I3DXMatrixMultiply\": () => (/* binding */ I3DXMatrixMultiply),\n/* harmony export */   \"I3DXMatrixAdd\": () => (/* binding */ I3DXMatrixAdd),\n/* harmony export */   \"I3DXMatrixSubtract\": () => (/* binding */ I3DXMatrixSubtract),\n/* harmony export */   \"I3DXMatrixScale\": () => (/* binding */ I3DXMatrixScale),\n/* harmony export */   \"I3DXVector\": () => (/* binding */ I3DXVector),\n/* harmony export */   \"I3DXVector3\": () => (/* binding */ I3DXVector3),\n/* harmony export */   \"I3DXVectorUnit\": () => (/* binding */ I3DXVectorUnit),\n/* harmony export */   \"I3DXVectorCross\": () => (/* binding */ I3DXVectorCross),\n/* harmony export */   \"I3DXVectorDot\": () => (/* binding */ I3DXVectorDot),\n/* harmony export */   \"I3DXVectorLength\": () => (/* binding */ I3DXVectorLength)\n/* harmony export */ });\nclass I3DXMatrix {\n    constructor(rows, cols) {\n        if (typeof cols == 'undefined') {\n            cols = rows;\n        }\n        this.rows = rows; // m\n        this.cols = cols; // n\n        this.data = new Float32Array(rows * cols);\n    }\n    _idx(i, j) {\n        return i * this.cols + j;\n    }\n    get(i, j) {\n        return this.data[this._idx(i, j)];\n    }\n    set(i, j, value) {\n        this.data[this._idx(i, j)] = value;\n    }\n    incr(i, j, value) {\n        this.data[this._idx(i, j)] += value;\n    }\n    debug() {\n        const rows = [];\n        for (let i = 0; i < this.rows; i++) {\n            rows.push([]);\n            for (let j = 0; j < this.cols; j++) {\n                rows[i].push(this.get(i, j));\n            }\n        }\n        console.table(rows);\n    }\n}\nfunction I3DXMatrixIdentity(size) {\n    const id = new I3DXMatrix(size, size);\n    for (let i = 0; i < size; i++) {\n        id.set(i, i, 1);\n    }\n    return id;\n}\nfunction I3DXTranslateMatrix(x, y, z) {\n    const m = I3DXMatrixIdentity(4);\n    m.set(0, 3, x);\n    m.set(1, 3, y);\n    m.set(2, 3, z);\n    return m;\n}\nfunction I3DXScaleMatrix(sx, sy, sz) {\n    const m = I3DXMatrixIdentity(4);\n    m.set(0, 0, sx);\n    m.set(1, 1, sy);\n    m.set(2, 2, sz);\n    return m;\n}\nfunction I3DXToRadian(f) {\n    return (f / 180) * Math.PI;\n}\nfunction I3DXRotateXMatrix(theta) {\n    const m = I3DXMatrixIdentity(4);\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    m.set(1, 1, c);\n    m.set(1, 2, -s);\n    m.set(2, 1, s);\n    m.set(2, 2, c);\n    return m;\n}\nfunction I3DXRotateYMatrix(theta) {\n    const m = I3DXMatrixIdentity(4);\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    m.set(0, 0, c);\n    m.set(0, 2, s);\n    m.set(2, 0, -s);\n    m.set(2, 2, c);\n    return m;\n}\nfunction I3DXRotateZMatrix(theta) {\n    const m = I3DXMatrixIdentity(4);\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    m.set(0, 0, c);\n    m.set(0, 1, -s);\n    m.set(1, 0, s);\n    m.set(1, 1, c);\n    return m;\n}\nfunction I3DXMatrixTranspose(A) {\n    const B = new I3DXMatrix(A.cols, A.rows);\n    for (let i = 0; i < A.rows; i++) {\n        for (let j = 0; j < A.cols; j++) {\n            B.set(j, i, A.get(i, j));\n        }\n    }\n    return B;\n}\nfunction I3DXMatrixMultiply(A, B) {\n    if (A.cols !== B.rows) {\n        const Adim = `(${A.rows},${A.cols})`;\n        const Bdim = `(${B.rows},${B.cols})`;\n        throw new Error(`Matrices must be multiplicable! ${Adim}:${Bdim}`);\n    }\n    const M = new I3DXMatrix(A.rows, B.cols);\n    // Shortcut for 3x3 matrices.\n    if (3 === A.rows && 3 === A.cols && 3 === B.rows && 3 === B.cols) {\n        M.data[0] = A.data[0] * B.data[0] + A.data[1] * B.data[3] + A.data[2] * B.data[6];\n        M.data[1] = A.data[0] * B.data[1] + A.data[1] * B.data[4] + A.data[2] * B.data[7];\n        M.data[2] = A.data[0] * B.data[2] + A.data[1] * B.data[5] + A.data[2] * B.data[8];\n        M.data[3] = A.data[3] * B.data[0] + A.data[4] * B.data[3] + A.data[5] * B.data[6];\n        M.data[4] = A.data[3] * B.data[1] + A.data[4] * B.data[4] + A.data[5] * B.data[7];\n        M.data[5] = A.data[3] * B.data[2] + A.data[4] * B.data[5] + A.data[5] * B.data[8];\n        M.data[6] = A.data[6] * B.data[0] + A.data[7] * B.data[3] + A.data[8] * B.data[6];\n        M.data[7] = A.data[6] * B.data[1] + A.data[7] * B.data[4] + A.data[8] * B.data[7];\n        M.data[8] = A.data[6] * B.data[2] + A.data[7] * B.data[5] + A.data[8] * B.data[8];\n    }\n    // Shortcut for 4x4\n    else if (4 === A.rows && 4 === A.cols && 4 === B.rows && 4 === B.cols) {\n        M.data[0] = A.data[0] * B.data[0] + A.data[1] * B.data[4] + A.data[2] * B.data[8] + A.data[3] * B.data[12];\n        M.data[1] = A.data[0] * B.data[1] + A.data[1] * B.data[5] + A.data[2] * B.data[9] + A.data[3] * B.data[13];\n        M.data[2] = A.data[0] * B.data[2] + A.data[1] * B.data[6] + A.data[2] * B.data[10] + A.data[3] * B.data[14];\n        M.data[3] = A.data[0] * B.data[3] + A.data[1] * B.data[7] + A.data[2] * B.data[11] + A.data[3] * B.data[15];\n        M.data[4] = A.data[4] * B.data[0] + A.data[5] * B.data[4] + A.data[6] * B.data[8] + A.data[7] * B.data[12];\n        M.data[5] = A.data[4] * B.data[1] + A.data[5] * B.data[5] + A.data[6] * B.data[9] + A.data[7] * B.data[13];\n        M.data[6] = A.data[4] * B.data[2] + A.data[5] * B.data[6] + A.data[6] * B.data[10] + A.data[7] * B.data[14];\n        M.data[7] = A.data[4] * B.data[3] + A.data[5] * B.data[7] + A.data[6] * B.data[11] + A.data[7] * B.data[15];\n        M.data[8] = A.data[8] * B.data[0] + A.data[9] * B.data[4] + A.data[10] * B.data[8] + A.data[11] * B.data[12];\n        M.data[9] = A.data[8] * B.data[1] + A.data[9] * B.data[5] + A.data[10] * B.data[9] + A.data[11] * B.data[13];\n        M.data[10] = A.data[8] * B.data[2] + A.data[9] * B.data[6] + A.data[10] * B.data[10] + A.data[11] * B.data[14];\n        M.data[11] = A.data[8] * B.data[3] + A.data[9] * B.data[7] + A.data[10] * B.data[11] + A.data[11] * B.data[15];\n        M.data[12] = A.data[12] * B.data[0] + A.data[13] * B.data[4] + A.data[14] * B.data[8] + A.data[15] * B.data[12];\n        M.data[13] = A.data[12] * B.data[1] + A.data[13] * B.data[5] + A.data[14] * B.data[9] + A.data[15] * B.data[13];\n        M.data[14] = A.data[12] * B.data[2] + A.data[13] * B.data[6] + A.data[14] * B.data[10] + A.data[15] * B.data[14];\n        M.data[15] = A.data[12] * B.data[3] + A.data[13] * B.data[7] + A.data[14] * B.data[11] + A.data[15] * B.data[15];\n    }\n    // Multiply anything.\n    else {\n        for (let i = 0; i < A.rows; i++) {\n            for (let j = 0; j < B.cols; j++) {\n                let t = 0;\n                for (let k = 0; k < A.cols; k++) {\n                    t += A.get(i, k) * B.get(k, j);\n                }\n                M.set(i, j, t);\n            }\n        }\n    }\n    return M;\n}\nfunction I3DXMatrixAdd(A, B) {\n    if ((A.rows !== B.rows) || (A.cols !== B.cols)) {\n        throw new Error(\"Matrices must be the same size!\");\n    }\n    const M = new I3DXMatrix(A.rows, A.cols);\n    const l = A.rows * A.cols;\n    for (let i = 0; i < l; i++) {\n        M.data[i] = A.data[i] + B.data[i];\n    }\n    return M;\n}\nfunction I3DXMatrixSubtract(A, B) {\n    if (A.rows !== B.rows || A.cols !== B.cols) {\n        throw new Error(\"Matrices must be the same size!\");\n    }\n    const M = new I3DXMatrix(A.rows, A.cols);\n    const l = A.rows * A.cols;\n    for (let i = 0; i < l; i++) {\n        M.data[i] = A.data[i] - B.data[i];\n    }\n    return M;\n}\nfunction I3DXMatrixScale(A, s) {\n    const B = new I3DXMatrix(A.rows, A.cols);\n    const l = A.rows * A.cols;\n    for (let i = 0; i < l; i++) {\n        B.data[i] = A.data[i] * s;\n    }\n    return B;\n}\nfunction I3DXVector(m) {\n    return new I3DXMatrix(m, 1);\n}\nfunction I3DXVector3(x, y, z) {\n    const v = I3DXVector(3);\n    v.data[0] = x;\n    v.data[1] = y;\n    v.data[2] = z;\n    return v;\n}\nfunction I3DXVectorUnit(a) {\n    return I3DXMatrixScale(a, 1 / I3DXVectorLength(a));\n}\nfunction I3DXVectorCross(a, b) {\n    const c = I3DXVector(3);\n    c.data[0] = a.data[1] * b.data[2] - a.data[2] * b.data[1];\n    c.data[1] = a.data[2] * b.data[0] - a.data[0] * b.data[2];\n    c.data[2] = a.data[0] * b.data[1] - a.data[1] * b.data[0];\n    return c;\n}\nfunction I3DXVectorDot(a, b) {\n    if (a.rows != b.rows || a.cols != b.cols) {\n        throw new Error(\"Vectors must be the same size!\");\n    }\n    let total = 0;\n    const l = a.rows * a.cols;\n    for (let i = 0; i < l; i++) {\n        total += a.data[i] * b.data[i];\n    }\n    return total;\n}\nfunction I3DXVectorLength(a) {\n    return Math.sqrt(I3DXVectorDot(a, a));\n}\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/matrix.ts?");

/***/ }),

/***/ "./src/indirect3d/utils.ts":
/*!*********************************!*\
  !*** ./src/indirect3d/utils.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"pack\": () => (/* binding */ pack),\n/* harmony export */   \"unpack\": () => (/* binding */ unpack),\n/* harmony export */   \"sqr\": () => (/* binding */ sqr)\n/* harmony export */ });\nfunction pack(a, b, c, d) {\n    return (a << 24) | (b << 16) | (c << 8) | d;\n}\nfunction unpack(x) {\n    var a = (x & 0xff000000) >>> 24, b = (x & 0x00ff0000) >>> 16, c = (x & 0x0000ff00) >>> 8, d = (x & 0x000000ff);\n    return [a, b, c, d];\n}\nfunction sqr(i) {\n    return i * i;\n}\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/utils.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _indirect3d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./indirect3d */ \"./src/indirect3d/index.ts\");\n/* harmony import */ var _indirect3d_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./indirect3d/color */ \"./src/indirect3d/color.ts\");\n\n(function main() {\n    var WIDTH = 640, HEIGHT = 480;\n    var container = document.getElementById('indirect-container');\n    var fixedTriangle = [\n        new _indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXVertex(2.5, -3.0, 0.0, (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.ARGB)(0xff, 0, 0, 0xff)),\n        new _indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXVertex(0.0, 3.0, 0.0, (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.ARGB)(0xff, 0, 0xff, 0)),\n        new _indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXVertex(-2.5, -3.0, 0.0, (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.ARGB)(0xff, 0xff, 0, 0)),\n        new _indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXVertex(2.5, -3.0, 0.0, (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.ARGB)(0xff, 0, 0, 0xff)),\n        //new I3DXVertex(2.5, -3.0, 0.0, ARGB(0x80,0,0,0xff))\n    ];\n    var movingTriangle = [\n        new _indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXVertex(2.5, -3.0, 0.0, (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.ARGB)(0x40, 0, 0, 0xff)),\n        new _indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXVertex(0.0, 3.0, 0.0, (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.ARGB)(0x40, 0, 0, 0xff)),\n        new _indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXVertex(-2.5, -3.0, 0.0, (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.ARGB)(0x40, 0, 0, 0xff)),\n        //new I3DXVertex(2.5, -3.0, 0.0, ARGB(0x80,0,0,0xff))\n    ];\n    // zAxis = [\n    //     new I3DXVertex(0, 0, 1000, XRGB(0, 0xff, 0)),\n    //     new I3DXVertex(0, 0, -1000, XRGB(0, 0xff, 0))\n    // ];\n    var id = (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXMatrixIdentity)(4), tmat = (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXTranslateMatrix)(0, 0, -10);\n    var matView = (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXMatrixLookAtLH)((0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXVector3)(0.0, 0.0, 30.0), // the camera position\n    (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXVector3)(0, 0, 0), // the \"look-at\" position\n    (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXVector3)(0, 1, 0)), // the \"up\" direction\n    matProj = (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXMatrixPerspectiveFovLH)((0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXToRadian)(45), // the horizontal field of view\n    WIDTH / HEIGHT, // aspect ratio\n    1.0, // near view-plane\n    100.0); // far view-plane\n    // matProj.debug();\n    let i3d = new _indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXDevice(container, WIDTH, HEIGHT);\n    let idx = 0;\n    i3d.SetTransform(_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DTS_VIEW, matView);\n    i3d.SetTransform(_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DTS_PROJECTION, matProj);\n    i3d.SetTransform(_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DTS_WORLD, id);\n    let isPlaying = false;\n    let lastFrameEnd;\n    function play() {\n        console.time('frame');\n        i3d.BeginScene();\n        var rot = (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXRotateYMatrix)(idx);\n        var rev = (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXRotateYMatrix)(-idx);\n        var left = (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXTranslateMatrix)(0, 0, 150);\n        i3d.SetTransform(_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DTS_WORLD, (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXMatrixAdd)((0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXMatrixMultiply)(rot, id), left));\n        i3d.DrawPrimitive(_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DPT_TRIANGLELIST, movingTriangle);\n        i3d.SetTransform(_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DTS_WORLD, (0,_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DXMatrixMultiply)(rev, id));\n        i3d.DrawPrimitive(_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DPT_TRIANGLELIST, fixedTriangle);\n        i3d.EndScene();\n        i3d.Present();\n        console.timeEnd('frame');\n        const now = Date.now();\n        const dt = now - lastFrameEnd;\n        idx += 0.005 * dt;\n        if (isPlaying) {\n            requestAnimationFrame(play);\n        }\n        lastFrameEnd = now;\n    }\n    window.addEventListener('keyup', function (e) {\n        if (e.keyCode == 27) { // Escape\n            isPlaying = false;\n            console.log(\"Stop animation.\");\n        }\n        else if (e.keyCode == 13) {\n            isPlaying = true;\n            lastFrameEnd = Date.now();\n            console.log(\"Start animation.\");\n            requestAnimationFrame(play);\n        }\n        e.preventDefault();\n        return false;\n    }, true);\n    console.log(\"Construct scene\", new Date());\n    i3d.BeginScene();\n    i3d.DrawPrimitive(_indirect3d__WEBPACK_IMPORTED_MODULE_0__.I3DPT_TRIANGLELIST, fixedTriangle);\n    i3d.EndScene();\n    i3d.Present();\n    console.log(\"End Construct scene\", new Date());\n})();\n\nconst red = (0,_indirect3d_color__WEBPACK_IMPORTED_MODULE_1__.XRGB)(0xff, 0, 0);\nconsole.log('red as int:', red);\nconst lab = (0,_indirect3d_color__WEBPACK_IMPORTED_MODULE_1__.ColorToLab)(red);\nconsole.log('in lab:', lab);\nconst rered = (0,_indirect3d_color__WEBPACK_IMPORTED_MODULE_1__.LabToColor)(...lab);\nconsole.log('as int again:', rered);\n\n\n//# sourceURL=webpack://indirect3d/./src/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;