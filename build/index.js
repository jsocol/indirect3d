/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/indirect3d/color.ts":
/*!*********************************!*\
  !*** ./src/indirect3d/color.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LabToXYZ = exports.XYZToLab = exports.XYZToRGB = exports.RGBToXYZ = exports.LabToColor = exports.ColorToLab = exports.I3DXAlphaBlend = exports.ARGB = exports.XRGB = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/indirect3d/utils.ts\");\nfunction XRGB(r, g, b) {\n    return {\n        a: 255,\n        r,\n        g,\n        b,\n    };\n}\nexports.XRGB = XRGB;\nfunction ARGB(a, r, g, b) {\n    return {\n        a,\n        r,\n        g,\n        b,\n    };\n}\nexports.ARGB = ARGB;\nfunction I3DXAlphaBlend(bg, fg) {\n    let { a: a0, r: r0, g: g0, b: b0 } = utils_1.unpack(bg);\n    let { a: a1, r: r1, g: g1, b: b1 } = utils_1.unpack(fg);\n    // src is transparent.\n    if (a1 === 0) {\n        return bg;\n    }\n    // bg is transparent.\n    if (a0 === 0) {\n        return fg;\n    }\n    a0 = a0 / 255;\n    a1 = a1 / 255;\n    //let a = a0 + a1 *() a0 * a1;\n    let a = a1 + a0 * (1 - a1);\n    const r = Math.round((r1 * a1 + r0 * a0 * (1 - a1)) / a);\n    const g = Math.round((g1 * a1 + g0 * a0 * (1 - a1)) / a);\n    const b = Math.round((b1 * a1 + b0 * a0 * (1 - a1)) / a);\n    a = Math.min(255, Math.round(a * 255));\n    return utils_1.pack(a, r, g, b);\n}\nexports.I3DXAlphaBlend = I3DXAlphaBlend;\nfunction ColorToLab(color) {\n    const { r, g, b } = color;\n    const [X, Y, Z] = RGBToXYZ(r, g, b);\n    return XYZToLab(X, Y, Z);\n}\nexports.ColorToLab = ColorToLab;\nfunction LabToColor(L, a, b) {\n    const [X, Y, Z] = LabToXYZ(L, a, b);\n    const [rc, gc, bc] = XYZToRGB(X, Y, Z);\n    return XRGB(rc, gc, bc);\n}\nexports.LabToColor = LabToColor;\n// These conversions come from http://www.easyrgb.com/en/math.php\nfunction RGBToXYZ(r, g, b) {\n    let rf = r / 255;\n    let gf = g / 255;\n    let bf = b / 255;\n    if (rf > 0.04045) {\n        rf = Math.pow(((rf + 0.055) / 1.055), 2.4);\n    }\n    else {\n        rf = rf / 12.92;\n    }\n    rf *= 100;\n    if (gf > 0.04045) {\n        gf = Math.pow(((gf + 0.055) / 1.055), 2.4);\n    }\n    else {\n        gf = gf / 12.92;\n    }\n    gf *= 100;\n    if (bf > 0.04045) {\n        bf = Math.pow(((bf + 0.055) / 1.055), 2.4);\n    }\n    else {\n        bf = bf / 12.92;\n    }\n    bf *= 100;\n    return [\n        rf * 0.4124 + gf * 0.3576 + bf * 0.1805,\n        rf * 0.2126 + gf * 0.7152 + bf * 0.0722,\n        rf * 0.0193 + gf * 0.1192 + bf * 0.9505,\n    ];\n}\nexports.RGBToXYZ = RGBToXYZ;\nfunction XYZToRGB(x, y, z) {\n    const vx = x / 100.0;\n    const vy = y / 100.0;\n    const vz = z / 100.0;\n    let vr = vx * 3.2406 + vy * -1.5372 + vz * -0.4986;\n    let vg = vx * -0.9689 + vy * 1.8758 + vz * 0.0415;\n    let vb = vx * 0.0557 + vy * -0.2040 + vz * 1.0570;\n    if (Math.abs(vr) > 0.0031308) {\n        vr = 1.055 * (Math.pow(vr, (1 / 2.4))) - 0.055;\n    }\n    else {\n        vr = 12.92 * vr;\n    }\n    if (Math.abs(vg) > 0.0031308) {\n        vg = 1.055 * (Math.pow(vg, (1 / 2.4))) - 0.055;\n    }\n    else {\n        vg = 12.92 * vg;\n    }\n    if (Math.abs(vb) > 0.0031308) {\n        vb = 1.055 * (Math.pow(vb, (1 / 2.4))) - 0.055;\n    }\n    else {\n        vb = 12.92 * vb;\n    }\n    return [\n        Math.min(Math.max(Math.round(vr * 255), 0), 255),\n        Math.min(Math.max(Math.round(vg * 255), 0), 255),\n        Math.min(Math.max(Math.round(vb * 255), 0), 255),\n    ];\n}\nexports.XYZToRGB = XYZToRGB;\n// Reference 2Â° (CIE 1931) / D65\nconst RefX = 95.047;\nconst RefY = 100;\nconst RefZ = 108.883;\nfunction XYZToLab(x, y, z) {\n    let vx = x / RefX;\n    let vy = y / RefY;\n    let vz = z / RefZ;\n    if (vx > 0.008856) {\n        vx = Math.pow(vx, (1 / 3));\n    }\n    else {\n        vx = (7.787 * vx) + (16 / 116);\n    }\n    if (vy > 0.008856) {\n        vy = Math.pow(vy, (1 / 3));\n    }\n    else {\n        vy = (7.787 * vy) + (16 / 116);\n    }\n    if (vz > 0.008856) {\n        vz = Math.pow(vz, (1 / 3));\n    }\n    else {\n        vz = (7.787 * vz) + (16 / 116);\n    }\n    return [\n        (116 * vy) - 16,\n        500 * (vx - vy),\n        200 * (vy - vz),\n    ];\n}\nexports.XYZToLab = XYZToLab;\nfunction LabToXYZ(L, a, b) {\n    let vy = (L + 16) / 116;\n    let vx = a / 500 + vy;\n    let vz = vy - b / 200;\n    if (Math.pow(vx, 3) > 0.008856) {\n        vx = Math.pow(vx, 3);\n    }\n    else {\n        vx = (vx - 16 / 116) / 7.787;\n    }\n    if (Math.pow(vy, 3) > 0.008856) {\n        vy = Math.pow(vy, 3);\n    }\n    else {\n        vy = (vy - 16 / 116) / 7.787;\n    }\n    if (Math.pow(vz, 3) > 0.008856) {\n        vz = Math.pow(vz, 3);\n    }\n    else {\n        vz = (vz - 16 / 116) / 7.787;\n    }\n    return [\n        vx * RefX,\n        vy * RefY,\n        vz * RefZ,\n    ];\n}\nexports.LabToXYZ = LabToXYZ;\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/color.ts?");

/***/ }),

/***/ "./src/indirect3d/device.ts":
/*!**********************************!*\
  !*** ./src/indirect3d/device.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.I3DXDevice = exports.I3DPT_TRIANGLEFAN = exports.I3DPT_TRIANGLESTRIP = exports.I3DPT_TRIANGLELIST = exports.I3DPT_LINESTRIP = exports.I3DPT_LINELIST = exports.I3DPT_POINTLIST = exports.I3DTS_PROJECTION = exports.I3DTS_VIEW = exports.I3DTS_WORLD = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/indirect3d/utils.ts\");\nconst color_1 = __webpack_require__(/*! ./color */ \"./src/indirect3d/color.ts\");\nconst matrix_1 = __webpack_require__(/*! ./matrix */ \"./src/indirect3d/matrix.ts\");\nconst geometry_1 = __webpack_require__(/*! ./geometry */ \"./src/indirect3d/geometry.ts\");\nconst lights_1 = __webpack_require__(/*! ./lights */ \"./src/indirect3d/lights.ts\");\nconst WHITE = color_1.XRGB(0xff, 0xff, 0xff);\nexports.I3DTS_WORLD = 'world';\nexports.I3DTS_VIEW = 'view';\nexports.I3DTS_PROJECTION = 'projection';\nexports.I3DPT_POINTLIST = 1;\nexports.I3DPT_LINELIST = 2;\nexports.I3DPT_LINESTRIP = 3;\nexports.I3DPT_TRIANGLELIST = 4;\nexports.I3DPT_TRIANGLESTRIP = 5;\nexports.I3DPT_TRIANGLEFAN = 6;\nclass I3DXDevice {\n    constructor(container, WIDTH, HEIGHT) {\n        this._ambientLight = {\n            r: 0.0,\n            g: 0.0,\n            b: 0.0,\n            a: 0.0,\n        };\n        this._lights = [];\n        this.WIDTH = WIDTH;\n        this.HWIDTH = WIDTH / 2;\n        this.HEIGHT = HEIGHT;\n        this.HHEIGHT = HEIGHT / 2;\n        this._canvas = document.createElement('canvas');\n        this._canvas.width = WIDTH;\n        this._canvas.height = HEIGHT;\n        container.appendChild(this._canvas);\n        this._ctx = this._canvas.getContext('2d');\n        this._backBuffer = this._ctx.createImageData(WIDTH, HEIGHT);\n        const defaultView = geometry_1.I3DXMatrixLookAtLH(matrix_1.I3DXVector3(0.0, 0.0, 10.0), matrix_1.I3DXVector3(0.0, 0.0, 0.0), matrix_1.I3DXVector3(0.0, 1.0, 0.0));\n        const defaultProjection = geometry_1.I3DXMatrixPerspectiveFovLH(matrix_1.I3DXToRadian(45), WIDTH / HEIGHT, 1, 100);\n        this._transforms = {\n            [exports.I3DTS_WORLD]: matrix_1.I3DXMatrixIdentity(4),\n            [exports.I3DTS_VIEW]: defaultView,\n            [exports.I3DTS_PROJECTION]: defaultProjection,\n        };\n        const bufferLength = this.WIDTH * this.HEIGHT;\n        this._zbufferData = new Int32Array(bufferLength);\n        this._zbufferDepth = new Float32Array(bufferLength);\n    }\n    SetAmbientLight(color) {\n        this._ambientLight = color;\n    }\n    SetLight(index, light) {\n        this._lights[index] = light;\n    }\n    GetLight(index) {\n        return this._lights[index];\n    }\n    SetTransform(type, matrix) {\n        this._transforms[type] = matrix;\n    }\n    MultiplyTransform(type, matrix) {\n        this._transforms[type] = matrix_1.I3DXMatrixMultiply(matrix, this._transforms[type]);\n    }\n    BeginScene() {\n        this.ZBufferClear();\n        this._backBuffer = this._ctx.createImageData(this.WIDTH, this.HEIGHT);\n    }\n    // Take a point in perspective space and its color, and draw it.\n    drawPoint(transformed4vec, color) {\n        const bx = transformed4vec.x / transformed4vec.w;\n        const by = transformed4vec.y / transformed4vec.w;\n        const bz = transformed4vec.z / transformed4vec.w;\n        // If this is in the field of view\n        if (Math.abs(bx) <= 1 &&\n            Math.abs(by) <= 1 &&\n            Math.abs(bz) <= 1) {\n            const sx = Math.round((1 - bx) * this.HWIDTH);\n            const sy = Math.round((1 - by) * this.HHEIGHT);\n            let { a, r, g, b } = color;\n            r = r * this._ambientLight.r;\n            g = g * this._ambientLight.g;\n            b = b * this._ambientLight.b;\n            this.ZBufferSet(sx, sy, utils_1.pack(a, r, g, b), bz);\n        }\n    }\n    // Take two points in perspective space and their colors, and interpolate a line between them.\n    drawLine(p0, c0, p1, c1) {\n        // convert to the screen\n        const bx0 = p0.x / p0.w;\n        const by0 = p0.y / p0.w;\n        const bz0 = p0.z / p0.w;\n        const bx1 = p1.x / p1.w;\n        const by1 = p1.y / p1.w;\n        const bz1 = p1.z / p1.w;\n        // Given a distance from 0 to 1 along a line segment\n        // between point f0 and point f1, return the appropriate\n        // color.\n        // TODO: This is a bad way to do coloring.\n        const { a: a0, r: r0, g: g0, b: b0 } = c0;\n        const { a: a1, r: r1, g: g1, b: b1 } = c1;\n        const da = a1 - a0;\n        const dr = r1 - r0;\n        const dg = g1 - g0;\n        const db = b1 - b0;\n        const color = (distance) => {\n            return utils_1.pack(Math.round(da * distance + a0), Math.round(dr * distance + r0), Math.round(dg * distance + g0), Math.round(db * distance + b0));\n        };\n        // Given a distance from 0 to 1 along a line segment\n        // between point f0 and point f1, return a 3D, transformed\n        // position.\n        const dx = bx1 - bx0;\n        const dy = by1 - by0;\n        const dz = bz1 - bz0;\n        const pos = (distance) => {\n            return [\n                dx * distance + bx0,\n                dy * distance + by0,\n                dz * distance + bz0,\n            ];\n        };\n        const sx0 = Math.round((1 - bx0) * this.HWIDTH);\n        const sx1 = Math.round((1 - bx1) * this.HWIDTH);\n        const dsx = Math.abs(sx1 - sx0);\n        for (let j = 0; j <= dsx; j++) {\n            const dist = j / dsx;\n            const [x, y, z] = pos(dist);\n            const c = color(dist);\n            if (Math.abs(x) < 1 &&\n                Math.abs(y) < 1 &&\n                Math.abs(z) < 1) {\n                const sx = Math.round((1 - x) * this.HWIDTH);\n                const sy = Math.round((1 - y) * this.HHEIGHT);\n                this.ZBufferSet(sx, sy, c, z);\n            }\n        }\n    }\n    drawTriangle(pCam, pColor, qCam, qColor, rCam, rColor) {\n        const screenNormal = matrix_1.I3DXVector3(0, 0, 1);\n        const lightPositions = this._lights.filter((light) => light.type === lights_1.I3DLightType.Point).map((light) => ({\n            light: light,\n            pos: matrix_1.I3DXMatrixMultiply(this._transforms[exports.I3DTS_VIEW], light.position),\n        }));\n        const nCam = matrix_1.I3DXVectorUnit(matrix_1.I3DXVectorCross(matrix_1.I3DXMatrixSubtract(qCam, pCam), matrix_1.I3DXMatrixSubtract(rCam, pCam)));\n        const pPers = matrix_1.I3DXMatrixMultiply(this._transforms[exports.I3DTS_PROJECTION], pCam).toColVec();\n        const qPers = matrix_1.I3DXMatrixMultiply(this._transforms[exports.I3DTS_PROJECTION], qCam).toColVec();\n        const rPers = matrix_1.I3DXMatrixMultiply(this._transforms[exports.I3DTS_PROJECTION], rCam).toColVec();\n        const P = matrix_1.I3DXVector3(pPers.x / pPers.w, pPers.y / pPers.w, pPers.z / pPers.w);\n        const Q = matrix_1.I3DXVector3(qPers.x / qPers.w, qPers.y / qPers.w, qPers.z / qPers.w);\n        const R = matrix_1.I3DXVector3(rPers.x / rPers.w, rPers.y / rPers.w, rPers.z / rPers.w);\n        const QP = matrix_1.I3DXMatrixSubtract(Q, P);\n        const RP = matrix_1.I3DXMatrixSubtract(R, P);\n        const RQ = matrix_1.I3DXMatrixSubtract(R, Q);\n        const PR = matrix_1.I3DXMatrixSubtract(P, R);\n        const N = matrix_1.I3DXVectorUnit(matrix_1.I3DXVectorCross(QP, RP));\n        // the final parameter to the equation of the plane\n        const d = matrix_1.I3DXVectorDot(screenNormal, P);\n        const dN = matrix_1.I3DXVectorDot(N, screenNormal);\n        // if dN === 0, the triangle _should_ be parallel to the ray\n        if (dN <= 0) {\n            return;\n        }\n        // Scaled coordinates\n        const Psx = Math.round((1 - P.data[0]) * this.HWIDTH);\n        const Psy = Math.round((1 - P.data[1]) * this.HHEIGHT);\n        const Qsx = Math.round((1 - Q.data[0]) * this.HWIDTH);\n        const Qsy = Math.round((1 - Q.data[1]) * this.HHEIGHT);\n        const Rsx = Math.round((1 - R.data[0]) * this.HWIDTH);\n        const Rsy = Math.round((1 - R.data[1]) * this.HHEIGHT);\n        // Corners of a boundins square\n        const Tp = Math.max(Math.min(Psy, Qsy, Rsy), 0);\n        const Bp = Math.min(Math.max(Psy, Qsy, Rsy), this.HEIGHT);\n        const Lp = Math.max(Math.min(Psx, Qsx, Rsx), 0);\n        const Rp = Math.min(Math.max(Psx, Qsx, Rsx), this.WIDTH);\n        const Pa = pColor.a;\n        const Qa = qColor.a;\n        const Ra = rColor.a;\n        const pNormColor = {\n            r: pColor.r / 255,\n            g: pColor.g / 255,\n            b: pColor.b / 255,\n        };\n        const qNormColor = {\n            r: qColor.r / 255,\n            g: qColor.g / 255,\n            b: qColor.b / 255,\n        };\n        const rNormColor = {\n            r: rColor.r / 255,\n            g: rColor.g / 255,\n            b: rColor.b / 255,\n        };\n        // Ambient light\n        const pLitColor = {\n            a: Pa,\n            r: pNormColor.r * this._ambientLight.r,\n            g: pNormColor.g * this._ambientLight.g,\n            b: pNormColor.b * this._ambientLight.b,\n        };\n        const qLitColor = {\n            a: Qa,\n            r: qNormColor.r * this._ambientLight.r,\n            g: qNormColor.g * this._ambientLight.g,\n            b: qNormColor.b * this._ambientLight.b,\n        };\n        const rLitColor = {\n            a: Ra,\n            r: rNormColor.r * this._ambientLight.r,\n            g: rNormColor.g * this._ambientLight.g,\n            b: rNormColor.b * this._ambientLight.b,\n        };\n        for (let l of lightPositions) {\n            let pLdir = matrix_1.I3DXMatrixSubtract(pCam, l.pos);\n            const pLdist = matrix_1.I3DXVectorLength(pLdir);\n            pLdir = matrix_1.I3DXMatrixScale(pLdir, 1 / pLdist);\n            const pLambert = Math.max(matrix_1.I3DXVectorDot(matrix_1.I3DXVector3(pLdir.data[0], pLdir.data[1], pLdir.data[2]), nCam), 0);\n            const pAtten = l.light.atten0 + l.light.atten1 * pLdist + l.light.atten2 * pLdist * pLdist;\n            pLitColor.r += pNormColor.r * l.light.diffuse.r * pLambert * 1.0 / pAtten;\n            pLitColor.g += pNormColor.g * l.light.diffuse.g * pLambert * 1.0 / pAtten;\n            pLitColor.b += pNormColor.b * l.light.diffuse.b * pLambert * 1.0 / pAtten;\n            let qLdir = matrix_1.I3DXMatrixSubtract(qCam, l.pos);\n            const qLdist = matrix_1.I3DXVectorLength(qLdir);\n            qLdir = matrix_1.I3DXMatrixScale(qLdir, 1 / qLdist);\n            const qLambert = Math.max(matrix_1.I3DXVectorDot(matrix_1.I3DXVector3(qLdir.data[0], qLdir.data[1], qLdir.data[2]), nCam), 0);\n            const qAtten = l.light.atten0 + l.light.atten1 * qLdist + l.light.atten2 * qLdist * qLdist;\n            qLitColor.r += qNormColor.r * l.light.diffuse.r * qLambert * 1.0 / qAtten;\n            qLitColor.g += qNormColor.g * l.light.diffuse.g * qLambert * 1.0 / qAtten;\n            qLitColor.b += qNormColor.b * l.light.diffuse.b * qLambert * 1.0 / qAtten;\n            let rLdir = matrix_1.I3DXMatrixSubtract(rCam, l.pos);\n            const rLdist = matrix_1.I3DXVectorLength(rLdir);\n            rLdir = matrix_1.I3DXMatrixScale(rLdir, 1 / rLdist);\n            const rLambert = Math.max(matrix_1.I3DXVectorDot(matrix_1.I3DXVector3(rLdir.data[0], rLdir.data[1], rLdir.data[2]), nCam), 0);\n            const rAtten = l.light.atten0 + l.light.atten1 * rLdist + l.light.atten2 * rLdist * rLdist;\n            rLitColor.r += rNormColor.r * l.light.diffuse.r * rLambert * 1.0 / rAtten;\n            rLitColor.g += rNormColor.g * l.light.diffuse.g * rLambert * 1.0 / rAtten;\n            rLitColor.b += rNormColor.b * l.light.diffuse.b * rLambert * 1.0 / rAtten;\n        }\n        pLitColor.r = Math.min(pLitColor.r, 1.0) * 255;\n        pLitColor.g = Math.min(pLitColor.g, 1.0) * 255;\n        pLitColor.b = Math.min(pLitColor.b, 1.0) * 255;\n        qLitColor.r = Math.min(qLitColor.r, 1.0) * 255;\n        qLitColor.g = Math.min(qLitColor.g, 1.0) * 255;\n        qLitColor.b = Math.min(qLitColor.b, 1.0) * 255;\n        rLitColor.r = Math.min(rLitColor.r, 1.0) * 255;\n        rLitColor.g = Math.min(rLitColor.g, 1.0) * 255;\n        rLitColor.b = Math.min(rLitColor.b, 1.0) * 255;\n        // Calculate light colors and convert to L*a*b*\n        const PLab = color_1.ColorToLab(pLitColor);\n        const QLab = color_1.ColorToLab(qLitColor);\n        const RLab = color_1.ColorToLab(rLitColor);\n        // x and y here are literally pixel coordinates\n        for (let y = Tp; y <= Bp; y++) {\n            for (let x = Lp; x <= Rp; x++) {\n                // convert x and y back to perspective space\n                const px = 1 - x / this.HWIDTH;\n                const py = 1 - y / this.HHEIGHT;\n                const sOrigin = matrix_1.I3DXVector3(px, py, 0);\n                // Depth at intersection with plane of the triangle\n                const z = (d - matrix_1.I3DXVectorDot(N, sOrigin)) / dN;\n                const O = matrix_1.I3DXVector3(px, py, z);\n                if (!(matrix_1.I3DXVectorDot(matrix_1.I3DXVectorCross(QP, matrix_1.I3DXMatrixSubtract(O, P)), N) >= 0 &&\n                    matrix_1.I3DXVectorDot(matrix_1.I3DXVectorCross(RQ, matrix_1.I3DXMatrixSubtract(O, Q)), N) >= 0 &&\n                    matrix_1.I3DXVectorDot(matrix_1.I3DXVectorCross(PR, matrix_1.I3DXMatrixSubtract(O, R)), N) >= 0)) {\n                    continue;\n                }\n                const [Wp, Wq, Wr] = geometry_1.I3DXBarycentricCoords(px, py, P.x, P.y, Q.x, Q.y, R.x, R.y);\n                const L = PLab[0] * Wp + QLab[0] * Wq + RLab[0] * Wr;\n                const a = PLab[1] * Wp + QLab[1] * Wq + RLab[1] * Wr;\n                const b = PLab[2] * Wp + QLab[2] * Wq + RLab[2] * Wr;\n                const { r: vr, g: vg, b: vb } = color_1.LabToColor(L, a, b);\n                const c = utils_1.pack(Math.round(Pa * Wp + Qa * Wq + Ra * Wr), vr, vg, vb);\n                this.ZBufferSet(x, y, c, z);\n            }\n        }\n    }\n    DrawPrimitive(mode, list) {\n        const transformCamera = matrix_1.I3DXMatrixMultiply(this._transforms[exports.I3DTS_VIEW], this._transforms[exports.I3DTS_WORLD]);\n        const transform = matrix_1.I3DXMatrixMultiply(this._transforms[exports.I3DTS_PROJECTION], transformCamera);\n        switch (mode) {\n            case exports.I3DPT_POINTLIST:\n                for (let i = 0; i < list.length; i++) {\n                    const f = matrix_1.I3DXMatrixMultiply(transform, list[i].coordinates);\n                    this.drawPoint(f, list[i].color);\n                }\n                break;\n            case exports.I3DPT_LINELIST:\n            case exports.I3DPT_LINESTRIP:\n                for (let i = 0; i < list.length - 1; i++) {\n                    // model space coordinates\n                    const p0 = list[i];\n                    const p1 = list[i + 1];\n                    // These should be points in the perspective space\n                    const f0 = matrix_1.I3DXMatrixMultiply(transform, p0.coordinates);\n                    const f1 = matrix_1.I3DXMatrixMultiply(transform, p1.coordinates);\n                    this.drawLine(f0, p0.color, f1, p1.color);\n                    if (mode === exports.I3DPT_LINELIST) {\n                        // Disconnect the lines by moving along the list\n                        i++;\n                    }\n                }\n                break;\n            case exports.I3DPT_TRIANGLELIST:\n            case exports.I3DPT_TRIANGLESTRIP:\n            case exports.I3DPT_TRIANGLEFAN:\n                for (let m = 0; m < list.length - 2;) {\n                    let i, j, k;\n                    if (mode === exports.I3DPT_TRIANGLELIST) {\n                        i = m;\n                        j = m + 1;\n                        k = m + 2;\n                        m += 3;\n                    }\n                    else if (mode === exports.I3DPT_TRIANGLESTRIP) {\n                        i = m;\n                        j = m + 1;\n                        k = m + 2;\n                        if (m % 2 === 1) {\n                            [j, k] = [k, j];\n                        }\n                        m++;\n                    }\n                    else {\n                        i = 0;\n                        j = m + 1;\n                        k = m + 2;\n                        m++;\n                    }\n                    const pCam = matrix_1.I3DXMatrixMultiply(transformCamera, list[i].coordinates);\n                    const qCam = matrix_1.I3DXMatrixMultiply(transformCamera, list[j].coordinates);\n                    const rCam = matrix_1.I3DXMatrixMultiply(transformCamera, list[k].coordinates);\n                    const pColor = list[i].color;\n                    const qColor = list[j].color;\n                    const rColor = list[k].color;\n                    this.drawTriangle(pCam, pColor, qCam, qColor, rCam, rColor);\n                }\n                break;\n        }\n    }\n    EndScene() {\n        const max = this.WIDTH * this.HEIGHT * 4;\n        for (let i = 0; i < max;) {\n            const { a, r, g, b } = utils_1.unpack(this._zbufferData[i / 4]);\n            this._backBuffer.data[i++] = r;\n            this._backBuffer.data[i++] = g;\n            this._backBuffer.data[i++] = b;\n            this._backBuffer.data[i++] = a;\n        }\n    }\n    Present() {\n        this._ctx.putImageData(this._backBuffer, 0, 0);\n    }\n    ZBufferSet(x, y, color, depth) {\n        const idx = this.WIDTH * (y - 1) + x;\n        const zdepth = this._zbufferDepth[idx];\n        const zcolor = this._zbufferData[idx];\n        // Current pixel is solid and closer\n        const { a: za } = utils_1.unpack(zcolor);\n        if (za >= 255 && zdepth < depth) {\n            return;\n        }\n        // New pixel is solid, or no current color\n        const { a } = utils_1.unpack(color);\n        if ((a >= 255 && depth < zdepth) || za === 0) {\n            this._zbufferData[idx] = color;\n            this._zbufferDepth[idx] = depth;\n            return;\n        }\n        // Nothing solid, blend 'em\n        if (depth > zdepth) {\n            this._zbufferData[idx] = color_1.I3DXAlphaBlend(color, zcolor);\n        }\n        else {\n            this._zbufferData[idx] = color_1.I3DXAlphaBlend(zcolor, color);\n        }\n        // Which is closer\n        if (depth < zdepth) {\n            this._zbufferDepth[idx] = depth;\n        }\n    }\n    ZBufferClear() {\n        const bufferLength = this.WIDTH * this.HEIGHT;\n        this._zbufferData = new Int32Array(bufferLength);\n        this._zbufferDepth = new Float32Array(bufferLength);\n    }\n}\nexports.I3DXDevice = I3DXDevice;\n;\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/device.ts?");

/***/ }),

/***/ "./src/indirect3d/geometry.ts":
/*!************************************!*\
  !*** ./src/indirect3d/geometry.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.I3DXBarycentricCoords = exports.I3DXMatrixOrthoLH = exports.I3DXMatrixPerspectiveFovLH = exports.I3DXMatrixLookToLH = exports.I3DXMatrixLookAtLH = exports.I3DXVertex = void 0;\nconst matrix_1 = __webpack_require__(/*! ./matrix */ \"./src/indirect3d/matrix.ts\");\nclass I3DXVertex {\n    constructor(x, y, z, color) {\n        const c = matrix_1.I3DXVector(4, [x, y, z, 1]);\n        this.coordinates = c;\n        this.color = color;\n    }\n}\nexports.I3DXVertex = I3DXVertex;\nfunction I3DXMatrixLookAtLH(pEye, pAt, pUp) {\n    const zaxis = matrix_1.I3DXVectorUnit(matrix_1.I3DXMatrixSubtract(pAt, pEye));\n    const xaxis = matrix_1.I3DXVectorUnit(matrix_1.I3DXVectorCross(pUp, zaxis));\n    const yaxis = matrix_1.I3DXVectorCross(zaxis, xaxis);\n    const xdot = matrix_1.I3DXVectorDot(xaxis, pEye);\n    const ydot = matrix_1.I3DXVectorDot(yaxis, pEye);\n    const zdot = matrix_1.I3DXVectorDot(zaxis, pEye);\n    // console.log('Vectors again!', xaxis.data, xaxis.x, xaxis.y, xaxis.z);\n    const matrix = new matrix_1.I3DXMatrix(4, 4, [\n        xaxis.data[0], xaxis.data[1], xaxis.data[2], -xdot,\n        yaxis.data[0], yaxis.data[1], yaxis.data[2], -ydot,\n        zaxis.data[0], zaxis.data[1], zaxis.data[2], -zdot,\n        0, 0, 0, 1,\n    ]);\n    return matrix;\n}\nexports.I3DXMatrixLookAtLH = I3DXMatrixLookAtLH;\nfunction I3DXMatrixLookToLH(pEye, pDir, pUp) {\n    const pAt = matrix_1.I3DXMatrixAdd(pEye, pDir);\n    return I3DXMatrixLookAtLH(pEye, pAt, pUp);\n}\nexports.I3DXMatrixLookToLH = I3DXMatrixLookToLH;\nfunction I3DXMatrixPerspectiveFovLH(fovy, aspect, zn, zf) {\n    const y = 1 / Math.tan(fovy / 2);\n    const x = y / aspect;\n    const zfn = zf / (zf - zn);\n    const matrix = new matrix_1.I3DXMatrix(4, 4, [\n        x, 0, 0, 0,\n        0, y, 0, 0,\n        0, 0, zfn, -zn * zfn,\n        0, 0, 1, 0,\n    ]);\n    return matrix;\n}\nexports.I3DXMatrixPerspectiveFovLH = I3DXMatrixPerspectiveFovLH;\nfunction I3DXMatrixOrthoLH(w, h, zn, zf) {\n    const zfzn = zf - zn;\n    const matrix = new matrix_1.I3DXMatrix(4, 4, [\n        2 / w, 0, 0, 0,\n        0, 2 / h, 0, 0,\n        0, 0, 1 / zfzn, -zn / zfzn,\n        0, 0, 0, 1,\n    ]);\n    return matrix;\n}\nexports.I3DXMatrixOrthoLH = I3DXMatrixOrthoLH;\nfunction I3DXBarycentricCoords(x, y, x1, y1, x2, y2, x3, y3) {\n    const y2y3 = y2 - y3;\n    const x3x2 = x3 - x2;\n    const x1x3 = x1 - x3;\n    const y1y3 = y1 - y3;\n    const y3y1 = y3 - y1;\n    const xx3 = x - x3;\n    const yy3 = y - y3;\n    const d = y2y3 * x1x3 + x3x2 * y1y3;\n    const w1 = (y2y3 * xx3 + x3x2 * yy3) / d;\n    const w2 = (y3y1 * xx3 + x1x3 * yy3) / d;\n    return [w1, w2, 1 - w1 - w2];\n}\nexports.I3DXBarycentricCoords = I3DXBarycentricCoords;\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/geometry.ts?");

/***/ }),

/***/ "./src/indirect3d/index.ts":
/*!*********************************!*\
  !*** ./src/indirect3d/index.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./color */ \"./src/indirect3d/color.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./device */ \"./src/indirect3d/device.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./geometry */ \"./src/indirect3d/geometry.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./matrix */ \"./src/indirect3d/matrix.ts\"), exports);\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/index.ts?");

/***/ }),

/***/ "./src/indirect3d/lights.ts":
/*!**********************************!*\
  !*** ./src/indirect3d/lights.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.I3DLight = exports.I3DLightType = void 0;\nvar I3DLightType;\n(function (I3DLightType) {\n    I3DLightType[I3DLightType[\"Point\"] = 1] = \"Point\";\n    I3DLightType[I3DLightType[\"Spot\"] = 2] = \"Spot\";\n    I3DLightType[I3DLightType[\"Directional\"] = 3] = \"Directional\";\n})(I3DLightType = exports.I3DLightType || (exports.I3DLightType = {}));\n;\nclass I3DLight {\n    constructor(type) {\n        this.atten0 = 1;\n        this.atten1 = 0;\n        this.atten2 = 0;\n        this.type = type;\n    }\n}\nexports.I3DLight = I3DLight;\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/lights.ts?");

/***/ }),

/***/ "./src/indirect3d/matrix.ts":
/*!**********************************!*\
  !*** ./src/indirect3d/matrix.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.I3DXVectorUnit = exports.I3DXVectorLength = exports.I3DXVectorDot = exports.I3DXVectorCross = exports.I3DXVector3 = exports.I3DXVector = exports.I3DXVec = exports.I3DXMatrixScale = exports.I3DXMatrixSubtract = exports.I3DXMatrixAdd = exports.I3DXMatrixMultiply = exports.I3DXMatrixTranspose = exports.I3DXRotateZMatrix = exports.I3DXRotateYMatrix = exports.I3DXRotateXMatrix = exports.I3DXToRadian = exports.I3DXScaleMatrix = exports.I3DXTranslateMatrix = exports.I3DXMatrixIdentity = exports.I3DXMatrix = void 0;\nclass I3DXMatrix {\n    constructor(rows, cols, data) {\n        if (typeof cols == 'undefined') {\n            cols = rows;\n        }\n        this.rows = rows; // m\n        this.cols = cols; // n\n        if (data) {\n            if (data.length !== rows * cols) {\n                throw new Error(\"data does not match matrix dimension\");\n            }\n            this.data = Float32Array.from(data);\n        }\n        else {\n            this.data = new Float32Array(rows * cols);\n        }\n    }\n    _idx(i, j) {\n        return i * this.cols + j;\n    }\n    get(i, j) {\n        return this.data[this._idx(i, j)];\n    }\n    set(i, j, value) {\n        this.data[this._idx(i, j)] = value;\n    }\n    incr(i, j, value) {\n        this.data[this._idx(i, j)] += value;\n    }\n    toColVec() {\n        return new I3DXVec(this.rows, 1, [...this.data]);\n    }\n    toRowVec() {\n        return new I3DXVec(this.cols, 1, [...this.data]);\n    }\n    debug() {\n        const rows = [];\n        for (let i = 0; i < this.rows; i++) {\n            rows.push([]);\n            for (let j = 0; j < this.cols; j++) {\n                rows[i].push(this.get(i, j));\n            }\n        }\n        console.table(rows);\n    }\n}\nexports.I3DXMatrix = I3DXMatrix;\nfunction I3DXMatrixIdentity(size) {\n    const id = new I3DXMatrix(size, size);\n    for (let i = 0; i < size; i++) {\n        id.set(i, i, 1);\n    }\n    return id;\n}\nexports.I3DXMatrixIdentity = I3DXMatrixIdentity;\nfunction I3DXTranslateMatrix(x, y, z) {\n    const m = I3DXMatrixIdentity(4);\n    m.set(0, 3, x);\n    m.set(1, 3, y);\n    m.set(2, 3, z);\n    return m;\n}\nexports.I3DXTranslateMatrix = I3DXTranslateMatrix;\nfunction I3DXScaleMatrix(sx, sy, sz) {\n    const m = I3DXMatrixIdentity(4);\n    m.set(0, 0, sx);\n    m.set(1, 1, sy);\n    m.set(2, 2, sz);\n    return m;\n}\nexports.I3DXScaleMatrix = I3DXScaleMatrix;\nfunction I3DXToRadian(f) {\n    return (f / 180) * Math.PI;\n}\nexports.I3DXToRadian = I3DXToRadian;\nfunction I3DXRotateXMatrix(theta) {\n    const m = I3DXMatrixIdentity(4);\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    m.set(1, 1, c);\n    m.set(1, 2, -s);\n    m.set(2, 1, s);\n    m.set(2, 2, c);\n    return m;\n}\nexports.I3DXRotateXMatrix = I3DXRotateXMatrix;\nfunction I3DXRotateYMatrix(theta) {\n    const m = I3DXMatrixIdentity(4);\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    m.set(0, 0, c);\n    m.set(0, 2, s);\n    m.set(2, 0, -s);\n    m.set(2, 2, c);\n    return m;\n}\nexports.I3DXRotateYMatrix = I3DXRotateYMatrix;\nfunction I3DXRotateZMatrix(theta) {\n    const m = I3DXMatrixIdentity(4);\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    m.set(0, 0, c);\n    m.set(0, 1, -s);\n    m.set(1, 0, s);\n    m.set(1, 1, c);\n    return m;\n}\nexports.I3DXRotateZMatrix = I3DXRotateZMatrix;\nfunction I3DXMatrixTranspose(A) {\n    const B = new I3DXMatrix(A.cols, A.rows);\n    for (let i = 0; i < A.rows; i++) {\n        for (let j = 0; j < A.cols; j++) {\n            B.set(j, i, A.get(i, j));\n        }\n    }\n    return B;\n}\nexports.I3DXMatrixTranspose = I3DXMatrixTranspose;\nfunction I3DXMatrixMultiply(A, B) {\n    if (A.cols !== B.rows) {\n        const Adim = `(${A.rows},${A.cols})`;\n        const Bdim = `(${B.rows},${B.cols})`;\n        throw new Error(`Matrices must be multiplicable! ${Adim}:${Bdim}`);\n    }\n    const M = new I3DXMatrix(A.rows, B.cols);\n    // Shortcut for 3x3 matrices.\n    if (3 === A.rows && 3 === A.cols && 3 === B.rows && 3 === B.cols) {\n        M.data[0] = A.data[0] * B.data[0] + A.data[1] * B.data[3] + A.data[2] * B.data[6];\n        M.data[1] = A.data[0] * B.data[1] + A.data[1] * B.data[4] + A.data[2] * B.data[7];\n        M.data[2] = A.data[0] * B.data[2] + A.data[1] * B.data[5] + A.data[2] * B.data[8];\n        M.data[3] = A.data[3] * B.data[0] + A.data[4] * B.data[3] + A.data[5] * B.data[6];\n        M.data[4] = A.data[3] * B.data[1] + A.data[4] * B.data[4] + A.data[5] * B.data[7];\n        M.data[5] = A.data[3] * B.data[2] + A.data[4] * B.data[5] + A.data[5] * B.data[8];\n        M.data[6] = A.data[6] * B.data[0] + A.data[7] * B.data[3] + A.data[8] * B.data[6];\n        M.data[7] = A.data[6] * B.data[1] + A.data[7] * B.data[4] + A.data[8] * B.data[7];\n        M.data[8] = A.data[6] * B.data[2] + A.data[7] * B.data[5] + A.data[8] * B.data[8];\n    }\n    // Shortcut for 4x4\n    else if (4 === A.rows && 4 === A.cols && 4 === B.rows && 4 === B.cols) {\n        M.data[0] = A.data[0] * B.data[0] + A.data[1] * B.data[4] + A.data[2] * B.data[8] + A.data[3] * B.data[12];\n        M.data[1] = A.data[0] * B.data[1] + A.data[1] * B.data[5] + A.data[2] * B.data[9] + A.data[3] * B.data[13];\n        M.data[2] = A.data[0] * B.data[2] + A.data[1] * B.data[6] + A.data[2] * B.data[10] + A.data[3] * B.data[14];\n        M.data[3] = A.data[0] * B.data[3] + A.data[1] * B.data[7] + A.data[2] * B.data[11] + A.data[3] * B.data[15];\n        M.data[4] = A.data[4] * B.data[0] + A.data[5] * B.data[4] + A.data[6] * B.data[8] + A.data[7] * B.data[12];\n        M.data[5] = A.data[4] * B.data[1] + A.data[5] * B.data[5] + A.data[6] * B.data[9] + A.data[7] * B.data[13];\n        M.data[6] = A.data[4] * B.data[2] + A.data[5] * B.data[6] + A.data[6] * B.data[10] + A.data[7] * B.data[14];\n        M.data[7] = A.data[4] * B.data[3] + A.data[5] * B.data[7] + A.data[6] * B.data[11] + A.data[7] * B.data[15];\n        M.data[8] = A.data[8] * B.data[0] + A.data[9] * B.data[4] + A.data[10] * B.data[8] + A.data[11] * B.data[12];\n        M.data[9] = A.data[8] * B.data[1] + A.data[9] * B.data[5] + A.data[10] * B.data[9] + A.data[11] * B.data[13];\n        M.data[10] = A.data[8] * B.data[2] + A.data[9] * B.data[6] + A.data[10] * B.data[10] + A.data[11] * B.data[14];\n        M.data[11] = A.data[8] * B.data[3] + A.data[9] * B.data[7] + A.data[10] * B.data[11] + A.data[11] * B.data[15];\n        M.data[12] = A.data[12] * B.data[0] + A.data[13] * B.data[4] + A.data[14] * B.data[8] + A.data[15] * B.data[12];\n        M.data[13] = A.data[12] * B.data[1] + A.data[13] * B.data[5] + A.data[14] * B.data[9] + A.data[15] * B.data[13];\n        M.data[14] = A.data[12] * B.data[2] + A.data[13] * B.data[6] + A.data[14] * B.data[10] + A.data[15] * B.data[14];\n        M.data[15] = A.data[12] * B.data[3] + A.data[13] * B.data[7] + A.data[14] * B.data[11] + A.data[15] * B.data[15];\n    }\n    // Multiply anything.\n    else {\n        for (let i = 0; i < A.rows; i++) {\n            for (let j = 0; j < B.cols; j++) {\n                let t = 0;\n                for (let k = 0; k < A.cols; k++) {\n                    t += A.get(i, k) * B.get(k, j);\n                }\n                M.set(i, j, t);\n            }\n        }\n    }\n    return M;\n}\nexports.I3DXMatrixMultiply = I3DXMatrixMultiply;\nfunction I3DXMatrixAdd(A, B) {\n    if ((A.rows !== B.rows) || (A.cols !== B.cols)) {\n        throw new Error(\"Matrices must be the same size!\");\n    }\n    const M = new I3DXMatrix(A.rows, A.cols);\n    const l = A.rows * A.cols;\n    for (let i = 0; i < l; i++) {\n        M.data[i] = A.data[i] + B.data[i];\n    }\n    return M;\n}\nexports.I3DXMatrixAdd = I3DXMatrixAdd;\nfunction I3DXMatrixSubtract(A, B) {\n    if (A.rows !== B.rows || A.cols !== B.cols) {\n        throw new Error(\"Matrices must be the same size!\");\n    }\n    const M = new I3DXMatrix(A.rows, A.cols);\n    const l = A.rows * A.cols;\n    for (let i = 0; i < l; i++) {\n        M.data[i] = A.data[i] - B.data[i];\n    }\n    return M;\n}\nexports.I3DXMatrixSubtract = I3DXMatrixSubtract;\nfunction I3DXMatrixScale(A, s) {\n    const B = new I3DXMatrix(A.rows, A.cols);\n    const l = A.rows * A.cols;\n    for (let i = 0; i < l; i++) {\n        B.data[i] = A.data[i] * s;\n    }\n    return B;\n}\nexports.I3DXMatrixScale = I3DXMatrixScale;\nclass I3DXVec extends I3DXMatrix {\n    constructor(rows, cols, data) {\n        super(rows, cols, data);\n    }\n    get x() {\n        return this.data[0];\n    }\n    set x(value) {\n        this.data[0] = value;\n    }\n    get y() {\n        return this.data[1];\n    }\n    set y(value) {\n        this.data[1] = value;\n    }\n    get z() {\n        return this.data[2];\n    }\n    set z(value) {\n        this.data[2] = value;\n    }\n    get w() {\n        return this.data[3];\n    }\n    set w(value) {\n        this.data[3] = value;\n    }\n    toVec3() {\n        return I3DXVector3(this.x, this.y, this.z);\n    }\n}\nexports.I3DXVec = I3DXVec;\nfunction I3DXVector(m, data) {\n    return new I3DXVec(m, 1, data);\n}\nexports.I3DXVector = I3DXVector;\nfunction I3DXVector3(x, y, z) {\n    const v = I3DXVector(3, [x, y, z]);\n    return v;\n}\nexports.I3DXVector3 = I3DXVector3;\nfunction I3DXVectorCross(a, b) {\n    const c = I3DXVector(3);\n    c.x = a.data[1] * b.data[2] - a.data[2] * b.data[1];\n    c.y = a.data[2] * b.data[0] - a.data[0] * b.data[2];\n    c.z = a.data[0] * b.data[1] - a.data[1] * b.data[0];\n    return c;\n}\nexports.I3DXVectorCross = I3DXVectorCross;\nfunction I3DXVectorDot(a, b) {\n    if (a.rows !== b.rows || a.cols !== b.cols) {\n        throw new Error(`Vectors must be the same size! (${a.rows}x${a.cols}) vs (${b.rows}x${b.cols})`);\n    }\n    let total = 0;\n    const l = a.rows * a.cols;\n    for (let i = 0; i < l; i++) {\n        total += a.data[i] * b.data[i];\n    }\n    return total;\n}\nexports.I3DXVectorDot = I3DXVectorDot;\nfunction I3DXVectorLength(a) {\n    return Math.sqrt(I3DXVectorDot(a, a));\n}\nexports.I3DXVectorLength = I3DXVectorLength;\nfunction I3DXVectorUnit(a) {\n    return I3DXMatrixScale(a, 1 / I3DXVectorLength(a));\n}\nexports.I3DXVectorUnit = I3DXVectorUnit;\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/matrix.ts?");

/***/ }),

/***/ "./src/indirect3d/utils.ts":
/*!*********************************!*\
  !*** ./src/indirect3d/utils.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sqr = exports.unpack = exports.pack = exports.clamp = void 0;\nfunction clamp(v, lo, hi) {\n    return Math.max(Math.min(v, hi), lo);\n}\nexports.clamp = clamp;\nfunction pack(a, b, c, d) {\n    return (clamp(a, 0, 255) << 24) | (clamp(b, 0, 255) << 16) | (clamp(c, 0, 255) << 8) | clamp(d, 0, 255);\n}\nexports.pack = pack;\nfunction unpack(x) {\n    const a = (x & 0xff000000) >>> 24, r = (x & 0x00ff0000) >>> 16, g = (x & 0x0000ff00) >>> 8, b = (x & 0x000000ff);\n    return { a, r, g, b };\n}\nexports.unpack = unpack;\nfunction sqr(i) {\n    return i * i;\n}\nexports.sqr = sqr;\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/utils.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* vim: set ts=2 sts=2 sw=2: */\nconst indirect3d_1 = __webpack_require__(/*! ./indirect3d */ \"./src/indirect3d/index.ts\");\nconst lights_1 = __webpack_require__(/*! ./indirect3d/lights */ \"./src/indirect3d/lights.ts\");\n(function main() {\n    const WIDTH = 640, HEIGHT = 480;\n    const container = document.getElementById('indirect-container');\n    const camXInput = document.getElementById('camera-x');\n    const camYInput = document.getElementById('camera-y');\n    const camZInput = document.getElementById('camera-z');\n    const dirXInput = document.getElementById('direction-x');\n    const dirYInput = document.getElementById('direction-y');\n    const dirZInput = document.getElementById('direction-z');\n    const fovyInput = document.getElementById('fovy');\n    const fpsMeter = document.getElementById('fps');\n    const redDepthInput = document.getElementById('red-depth-input');\n    const blueDepthInput = document.getElementById('blue-depth-input');\n    const fixedTriangle = [\n        new indirect3d_1.I3DXVertex(-2.5, -3.0, 0.0, indirect3d_1.ARGB(0xff, 0xff, 0, 0)),\n        new indirect3d_1.I3DXVertex(0.0, 3.0, 0.0, indirect3d_1.ARGB(0xff, 0, 0xff, 0)),\n        new indirect3d_1.I3DXVertex(2.5, -3.0, 0.0, indirect3d_1.ARGB(0xff, 0, 0, 0xff)),\n    ];\n    const pyramid = [\n        new indirect3d_1.I3DXVertex(0, 1, 0, indirect3d_1.XRGB(0xff, 0xff, 0xff)),\n        new indirect3d_1.I3DXVertex(-1, 0, 0, indirect3d_1.XRGB(0xff, 0x40, 0x40)),\n        new indirect3d_1.I3DXVertex(0, 0, -1, indirect3d_1.XRGB(0xff, 0xff, 0x40)),\n        new indirect3d_1.I3DXVertex(1, 0, 0, indirect3d_1.XRGB(0x40, 0x40, 0xff)),\n        new indirect3d_1.I3DXVertex(0, 0, 1, indirect3d_1.XRGB(0x40, 0xff, 0x40)),\n        new indirect3d_1.I3DXVertex(-1, 0, 0, indirect3d_1.XRGB(0xff, 0x40, 0x40)),\n    ];\n    const yellow = indirect3d_1.ARGB(0xff, 0xff, 0xff, 0xff);\n    const darkyellow = indirect3d_1.ARGB(0xff, 0xff, 0xff, 0xff);\n    // const darkyellow = ARGB(0x80, 0xc0, 0x8f, 0x40);\n    const root2o2 = Math.sqrt(2) / 2;\n    const root2m2 = Math.sqrt(2 - Math.sqrt(2)) / 2;\n    const root2p2 = Math.sqrt(2 + Math.sqrt(2)) / 2;\n    const ring = [\n        new indirect3d_1.I3DXVertex(1, 1, 0, yellow),\n        new indirect3d_1.I3DXVertex(root2p2, 0, root2m2, darkyellow),\n        new indirect3d_1.I3DXVertex(root2o2, 1, root2o2, yellow),\n        new indirect3d_1.I3DXVertex(root2m2, 0, root2p2, darkyellow),\n        new indirect3d_1.I3DXVertex(0, 1, 1, yellow),\n        new indirect3d_1.I3DXVertex(-root2m2, 0, root2p2, darkyellow),\n        new indirect3d_1.I3DXVertex(-root2o2, 1, root2o2, yellow),\n        new indirect3d_1.I3DXVertex(-root2p2, 0, root2m2, darkyellow),\n        new indirect3d_1.I3DXVertex(-1, 1, 0, yellow),\n        new indirect3d_1.I3DXVertex(-root2p2, 0, -root2m2, darkyellow),\n        new indirect3d_1.I3DXVertex(-root2o2, 1, -root2o2, yellow),\n        new indirect3d_1.I3DXVertex(-root2m2, 0, -root2p2, darkyellow),\n        new indirect3d_1.I3DXVertex(0, 1, -1, yellow),\n        new indirect3d_1.I3DXVertex(root2m2, 0, -root2p2, darkyellow),\n        new indirect3d_1.I3DXVertex(root2o2, 1, -root2o2, yellow),\n        new indirect3d_1.I3DXVertex(root2p2, 0, -root2m2, darkyellow),\n        new indirect3d_1.I3DXVertex(1, 1, 0, yellow),\n        new indirect3d_1.I3DXVertex(root2p2, 0, root2m2, darkyellow),\n        new indirect3d_1.I3DXVertex(root2o2, 1, root2o2, yellow),\n        new indirect3d_1.I3DXVertex(root2p2, 0, root2m2, darkyellow),\n        new indirect3d_1.I3DXVertex(1, 1, 0, yellow),\n        new indirect3d_1.I3DXVertex(root2p2, 0, -root2m2, darkyellow),\n        new indirect3d_1.I3DXVertex(root2o2, 1, -root2o2, yellow),\n        new indirect3d_1.I3DXVertex(root2m2, 0, -root2p2, darkyellow),\n        new indirect3d_1.I3DXVertex(0, 1, -1, yellow),\n        new indirect3d_1.I3DXVertex(-root2m2, 0, -root2p2, darkyellow),\n        new indirect3d_1.I3DXVertex(-root2o2, 1, -root2o2, yellow),\n        new indirect3d_1.I3DXVertex(-root2p2, 0, -root2m2, darkyellow),\n        new indirect3d_1.I3DXVertex(-1, 1, 0, yellow),\n        new indirect3d_1.I3DXVertex(-root2p2, 0, root2m2, darkyellow),\n        new indirect3d_1.I3DXVertex(-root2o2, 1, root2o2, yellow),\n        new indirect3d_1.I3DXVertex(-root2m2, 0, root2p2, darkyellow),\n        new indirect3d_1.I3DXVertex(0, 1, 1, yellow),\n        new indirect3d_1.I3DXVertex(root2m2, 0, root2p2, darkyellow),\n        new indirect3d_1.I3DXVertex(root2o2, 1, root2o2, yellow),\n        new indirect3d_1.I3DXVertex(root2p2, 0, root2m2, darkyellow),\n        new indirect3d_1.I3DXVertex(1, 1, 0, yellow),\n    ];\n    const ringSize = indirect3d_1.I3DXMatrixMultiply(indirect3d_1.I3DXScaleMatrix(2, 1, 2), indirect3d_1.I3DXTranslateMatrix(0, -0.5, 0));\n    const id = indirect3d_1.I3DXMatrixIdentity(4);\n    const vUp = indirect3d_1.I3DXVector3(0, 1, 0);\n    const triLeftFront = [\n        new indirect3d_1.I3DXVertex(0, 0, 0, indirect3d_1.ARGB(0x80, 0, 0, 0xff)),\n        new indirect3d_1.I3DXVertex(1, 1, 0, indirect3d_1.ARGB(0x80, 0, 0, 0xff)),\n        new indirect3d_1.I3DXVertex(2, 0, 0, indirect3d_1.ARGB(0x80, 0, 0, 0xff)),\n    ];\n    const triLeftBack = [\n        new indirect3d_1.I3DXVertex(0, 0, 0, indirect3d_1.XRGB(0xff, 0, 0)),\n        new indirect3d_1.I3DXVertex(1, 1, 0, indirect3d_1.XRGB(0xff, 0, 0)),\n        new indirect3d_1.I3DXVertex(2, 0, 0, indirect3d_1.XRGB(0xff, 0, 0)),\n    ];\n    let facing = indirect3d_1.I3DXVector(4, [0, 0, -1, 0]);\n    const matView = indirect3d_1.I3DXMatrixLookToLH(indirect3d_1.I3DXVector3(camXInput.valueAsNumber, camYInput.valueAsNumber, camZInput.valueAsNumber), // the camera position\n    indirect3d_1.I3DXVector3(facing.data[0], facing.data[1], facing.data[2]), // the \"look-to\" direction\n    vUp);\n    const matProj = indirect3d_1.I3DXMatrixPerspectiveFovLH(indirect3d_1.I3DXToRadian(fovyInput.valueAsNumber), // the horizontal field of view\n    WIDTH / HEIGHT, // aspect ratio\n    1.0, // near view-plane\n    100.0);\n    const i3d = new indirect3d_1.I3DXDevice(container, WIDTH, HEIGHT);\n    i3d.SetAmbientLight(indirect3d_1.XRGB(0.1, 0.1, 0.1));\n    i3d.SetTransform(indirect3d_1.I3DTS_VIEW, matView);\n    i3d.SetTransform(indirect3d_1.I3DTS_PROJECTION, matProj);\n    i3d.SetTransform(indirect3d_1.I3DTS_WORLD, id);\n    const basicLight = new lights_1.I3DLight(lights_1.I3DLightType.Point);\n    basicLight.diffuse = {\n        a: 0.0,\n        r: 0.15,\n        g: 0.0,\n        b: 0.5,\n    };\n    basicLight.position = indirect3d_1.I3DXVector(4, [-8, 5, 15, 1]);\n    basicLight.atten0 = 0;\n    basicLight.atten1 = 0.01;\n    basicLight.atten2 = 0.001;\n    i3d.SetLight(0, basicLight);\n    const keyLight = new lights_1.I3DLight(lights_1.I3DLightType.Point);\n    keyLight.diffuse = {\n        a: 0.0,\n        r: 0.5,\n        g: 0.7,\n        b: 0.2,\n    };\n    keyLight.position = indirect3d_1.I3DXVector(4, [1, 3, -15, 1]);\n    keyLight.atten0 = 0;\n    keyLight.atten1 = 0.1;\n    keyLight.atten2 = 0.001;\n    i3d.SetLight(1, keyLight);\n    let idx = 0;\n    let dPosition = 0.2;\n    let dTheta = 0.005;\n    let isPlaying = false;\n    let lastFrameEnd;\n    let frameTime = 0;\n    const keys = {\n        'KeyW': false,\n        'KeyQ': false,\n        'KeyE': false,\n        'KeyS': false,\n        'KeyA': false,\n        'KeyD': false, // turn right\n    };\n    function play() {\n        //console.time('frame');\n        let now = Date.now();\n        const dt = now - lastFrameEnd;\n        i3d.BeginScene();\n        // turning\n        facing = indirect3d_1.I3DXVectorUnit(indirect3d_1.I3DXVector(4, [dirXInput.valueAsNumber, dirYInput.valueAsNumber, dirZInput.valueAsNumber, 1]));\n        if (keys['KeyA']) {\n            const rotate = indirect3d_1.I3DXRotateYMatrix(dTheta * dt);\n            facing = indirect3d_1.I3DXMatrixMultiply(rotate, facing);\n        }\n        else if (keys['KeyD']) {\n            const rotate = indirect3d_1.I3DXRotateYMatrix(-dTheta * dt);\n            facing = indirect3d_1.I3DXMatrixMultiply(rotate, facing);\n        }\n        dirXInput.valueAsNumber = facing.data[0];\n        dirYInput.valueAsNumber = facing.data[1];\n        dirZInput.valueAsNumber = facing.data[2];\n        // moving\n        if (keys['KeyW']) {\n            const mvmt = indirect3d_1.I3DXMatrixScale(facing, dPosition * dt);\n            camXInput.valueAsNumber += mvmt.data[0];\n            camYInput.valueAsNumber += mvmt.data[1];\n            camZInput.valueAsNumber += mvmt.data[2];\n        }\n        else if (keys['KeyS']) {\n            const mvmt = indirect3d_1.I3DXMatrixScale(facing, -dPosition * dt);\n            camXInput.valueAsNumber += mvmt.data[0];\n            camYInput.valueAsNumber += mvmt.data[1];\n            camZInput.valueAsNumber += mvmt.data[2];\n        }\n        if (keys['KeyQ']) {\n            const vLeft = indirect3d_1.I3DXVectorUnit(indirect3d_1.I3DXVectorCross(vUp, facing));\n            const mvmt = indirect3d_1.I3DXMatrixScale(vLeft, dPosition * dt / 10);\n            camXInput.valueAsNumber += mvmt.data[0];\n            camYInput.valueAsNumber += mvmt.data[1];\n            camZInput.valueAsNumber += mvmt.data[2];\n        }\n        else if (keys['KeyE']) {\n            const vLeft = indirect3d_1.I3DXVectorUnit(indirect3d_1.I3DXVectorCross(vUp, facing));\n            const mvmt = indirect3d_1.I3DXMatrixScale(vLeft, -dPosition * dt / 10);\n            camXInput.valueAsNumber += mvmt.data[0];\n            camYInput.valueAsNumber += mvmt.data[1];\n            camZInput.valueAsNumber += mvmt.data[2];\n        }\n        const matView = indirect3d_1.I3DXMatrixLookToLH(indirect3d_1.I3DXVector3(camXInput.valueAsNumber, camYInput.valueAsNumber, camZInput.valueAsNumber), // the camera position\n        indirect3d_1.I3DXVector3(facing.data[0], facing.data[1], facing.data[2]), // the \"look-to\" direction\n        vUp);\n        const matProj = indirect3d_1.I3DXMatrixPerspectiveFovLH(indirect3d_1.I3DXToRadian(fovyInput.valueAsNumber), // the horizontal field of view\n        WIDTH / HEIGHT, // aspect ratio\n        1.0, // near view-plane\n        100.0);\n        i3d.SetTransform(indirect3d_1.I3DTS_VIEW, matView);\n        i3d.SetTransform(indirect3d_1.I3DTS_PROJECTION, matProj);\n        i3d.SetTransform(indirect3d_1.I3DTS_WORLD, id);\n        const blueDepth = blueDepthInput.valueAsNumber;\n        const blueTransform = indirect3d_1.I3DXTranslateMatrix(-9, 2, blueDepth);\n        i3d.SetTransform(indirect3d_1.I3DTS_WORLD, blueTransform);\n        i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLELIST, triLeftFront);\n        const redDepth = redDepthInput.valueAsNumber;\n        const redTransform = indirect3d_1.I3DXTranslateMatrix(-9, 2, redDepth);\n        i3d.SetTransform(indirect3d_1.I3DTS_WORLD, redTransform);\n        i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLELIST, triLeftBack);\n        i3d.SetTransform(indirect3d_1.I3DTS_WORLD, indirect3d_1.I3DXMatrixMultiply(indirect3d_1.I3DXRotateXMatrix(idx / 3), ringSize));\n        i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLESTRIP, ring);\n        const left = indirect3d_1.I3DXTranslateMatrix(0, 0, Math.sin(idx / 2));\n        i3d.SetTransform(indirect3d_1.I3DTS_WORLD, left);\n        i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLESTRIP, fixedTriangle);\n        i3d.SetTransform(indirect3d_1.I3DTS_WORLD, indirect3d_1.I3DXRotateYMatrix(idx / 3));\n        i3d.MultiplyTransform(indirect3d_1.I3DTS_WORLD, indirect3d_1.I3DXTranslateMatrix(8, 0, 0));\n        i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLEFAN, pyramid);\n        i3d.EndScene();\n        i3d.Present();\n        //console.timeEnd('frame');\n        idx += 0.005 * dt;\n        if (isPlaying) {\n            requestAnimationFrame(play);\n        }\n        frameTime += (now - lastFrameEnd - frameTime) / 20;\n        lastFrameEnd = now;\n    }\n    setInterval(() => {\n        fpsMeter.innerText = (1000 / frameTime).toFixed(1) + ' fps';\n    }, 500);\n    window.addEventListener('keydown', function (e) {\n        if (e.code in keys) {\n            keys[e.code] = true;\n        }\n    });\n    window.addEventListener('keyup', function (e) {\n        if (e.code in keys) {\n            keys[e.code] = false;\n        }\n        else if (e.code == 'Enter') {\n            isPlaying = !isPlaying;\n            if (isPlaying) {\n                lastFrameEnd = Date.now();\n                requestAnimationFrame(play);\n            }\n        }\n        e.preventDefault();\n        return false;\n    }, true);\n    i3d.BeginScene();\n    i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLESTRIP, fixedTriangle);\n    i3d.SetTransform(indirect3d_1.I3DTS_WORLD, indirect3d_1.I3DXScaleMatrix(2, 1, 2));\n    i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLESTRIP, ring);\n    i3d.EndScene();\n    i3d.Present();\n})();\n\n\n//# sourceURL=webpack://indirect3d/./src/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;