/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/indirect3d/color.ts":
/*!*********************************!*\
  !*** ./src/indirect3d/color.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LabToXYZ = exports.XYZToLab = exports.XYZToRGB = exports.RGBToXYZ = exports.LabToColor = exports.ColorToLab = exports.I3DXAlphaBlend = exports.ARGB = exports.XRGB = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/indirect3d/utils.ts\");\nfunction XRGB(r, g, b) {\n    return utils_1.pack(255, r, g, b);\n}\nexports.XRGB = XRGB;\nfunction ARGB(a, r, g, b) {\n    return utils_1.pack(a, r, g, b);\n}\nexports.ARGB = ARGB;\nfunction I3DXAlphaBlend(bg, fg) {\n    let [a0, r0, g0, b0] = utils_1.unpack(bg);\n    let [a1, r1, g1, b1] = utils_1.unpack(fg);\n    // src is transparent.\n    if (a1 === 0) {\n        return bg;\n    }\n    // bg is transparent.\n    if (a0 === 0) {\n        return fg;\n    }\n    a0 = a0 / 255;\n    a1 = a1 / 255;\n    //let a = a0 + a1 *() a0 * a1;\n    let a = a1 + a0 * (1 - a1);\n    const r = Math.round((r1 * a1 + r0 * a0 * (1 - a1)) / a);\n    const g = Math.round((g1 * a1 + g0 * a0 * (1 - a1)) / a);\n    const b = Math.round((b1 * a1 + b0 * a0 * (1 - a1)) / a);\n    a = Math.min(255, Math.round(a * 255));\n    return utils_1.pack(a, r, g, b);\n}\nexports.I3DXAlphaBlend = I3DXAlphaBlend;\nfunction ColorToLab(color) {\n    const [_, r, g, b] = utils_1.unpack(color);\n    const [X, Y, Z] = RGBToXYZ(r, g, b);\n    return XYZToLab(X, Y, Z);\n}\nexports.ColorToLab = ColorToLab;\nfunction LabToColor(L, a, b) {\n    const [X, Y, Z] = LabToXYZ(L, a, b);\n    const [rc, gc, bc] = XYZToRGB(X, Y, Z);\n    return XRGB(rc, gc, bc);\n}\nexports.LabToColor = LabToColor;\n// These conversions come from http://www.easyrgb.com/en/math.php\nfunction RGBToXYZ(r, g, b) {\n    let rf = r / 255;\n    let gf = g / 255;\n    let bf = b / 255;\n    if (rf > 0.04045) {\n        rf = Math.pow(((rf + 0.055) / 1.055), 2.4);\n    }\n    else {\n        rf = rf / 12.92;\n    }\n    rf *= 100;\n    if (gf > 0.04045) {\n        gf = Math.pow(((gf + 0.055) / 1.055), 2.4);\n    }\n    else {\n        gf = gf / 12.92;\n    }\n    gf *= 100;\n    if (bf > 0.04045) {\n        bf = Math.pow(((bf + 0.055) / 1.055), 2.4);\n    }\n    else {\n        bf = bf / 12.92;\n    }\n    bf *= 100;\n    return [\n        rf * 0.4124 + gf * 0.3576 + bf * 0.1805,\n        rf * 0.2126 + gf * 0.7152 + bf * 0.0722,\n        rf * 0.0193 + gf * 0.1192 + bf * 0.9505,\n    ];\n}\nexports.RGBToXYZ = RGBToXYZ;\nfunction XYZToRGB(x, y, z) {\n    const vx = x / 100.0;\n    const vy = y / 100.0;\n    const vz = z / 100.0;\n    let vr = vx * 3.2406 + vy * -1.5372 + vz * -0.4986;\n    let vg = vx * -0.9689 + vy * 1.8758 + vz * 0.0415;\n    let vb = vx * 0.0557 + vy * -0.2040 + vz * 1.0570;\n    if (Math.abs(vr) > 0.0031308) {\n        vr = 1.055 * (Math.pow(vr, (1 / 2.4))) - 0.055;\n    }\n    else {\n        vr = 12.92 * vr;\n    }\n    if (Math.abs(vg) > 0.0031308) {\n        vg = 1.055 * (Math.pow(vg, (1 / 2.4))) - 0.055;\n    }\n    else {\n        vg = 12.92 * vg;\n    }\n    if (Math.abs(vb) > 0.0031308) {\n        vb = 1.055 * (Math.pow(vb, (1 / 2.4))) - 0.055;\n    }\n    else {\n        vb = 12.92 * vb;\n    }\n    return [\n        Math.min(Math.max(Math.round(vr * 255), 0), 255),\n        Math.min(Math.max(Math.round(vg * 255), 0), 255),\n        Math.min(Math.max(Math.round(vb * 255), 0), 255),\n    ];\n}\nexports.XYZToRGB = XYZToRGB;\n// Reference 2Â° (CIE 1931) / D65\nconst RefX = 95.047;\nconst RefY = 100;\nconst RefZ = 108.883;\nfunction XYZToLab(x, y, z) {\n    let vx = x / RefX;\n    let vy = y / RefY;\n    let vz = z / RefZ;\n    if (vx > 0.008856) {\n        vx = Math.pow(vx, (1 / 3));\n    }\n    else {\n        vx = (7.787 * vx) + (16 / 116);\n    }\n    if (vy > 0.008856) {\n        vy = Math.pow(vy, (1 / 3));\n    }\n    else {\n        vy = (7.787 * vy) + (16 / 116);\n    }\n    if (vz > 0.008856) {\n        vz = Math.pow(vz, (1 / 3));\n    }\n    else {\n        vz = (7.787 * vz) + (16 / 116);\n    }\n    return [\n        (116 * vy) - 16,\n        500 * (vx - vy),\n        200 * (vy - vz),\n    ];\n}\nexports.XYZToLab = XYZToLab;\nfunction LabToXYZ(L, a, b) {\n    let vy = (L + 16) / 116;\n    let vx = a / 500 + vy;\n    let vz = vy - b / 200;\n    if (Math.pow(vx, 3) > 0.008856) {\n        vx = Math.pow(vx, 3);\n    }\n    else {\n        vx = (vx - 16 / 116) / 7.787;\n    }\n    if (Math.pow(vy, 3) > 0.008856) {\n        vy = Math.pow(vy, 3);\n    }\n    else {\n        vy = (vy - 16 / 116) / 7.787;\n    }\n    if (Math.pow(vz, 3) > 0.008856) {\n        vz = Math.pow(vz, 3);\n    }\n    else {\n        vz = (vz - 16 / 116) / 7.787;\n    }\n    return [\n        vx * RefX,\n        vy * RefY,\n        vz * RefZ,\n    ];\n}\nexports.LabToXYZ = LabToXYZ;\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/color.ts?");

/***/ }),

/***/ "./src/indirect3d/device.ts":
/*!**********************************!*\
  !*** ./src/indirect3d/device.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.I3DXDevice = exports.I3DPT_TRIANGLEFAN = exports.I3DPT_TRIANGLESTRIP = exports.I3DPT_TRIANGLELIST = exports.I3DPT_LINESTRIP = exports.I3DPT_LINELIST = exports.I3DPT_POINTLIST = exports.I3DTS_PROJECTION = exports.I3DTS_VIEW = exports.I3DTS_WORLD = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/indirect3d/utils.ts\");\nconst color_1 = __webpack_require__(/*! ./color */ \"./src/indirect3d/color.ts\");\nconst matrix_1 = __webpack_require__(/*! ./matrix */ \"./src/indirect3d/matrix.ts\");\nconst geometry_1 = __webpack_require__(/*! ./geometry */ \"./src/indirect3d/geometry.ts\");\nexports.I3DTS_WORLD = 'world';\nexports.I3DTS_VIEW = 'view';\nexports.I3DTS_PROJECTION = 'projection';\nexports.I3DPT_POINTLIST = 1;\nexports.I3DPT_LINELIST = 2;\nexports.I3DPT_LINESTRIP = 3;\nexports.I3DPT_TRIANGLELIST = 4;\nexports.I3DPT_TRIANGLESTRIP = 5;\nexports.I3DPT_TRIANGLEFAN = 6;\nclass I3DXDevice {\n    constructor(container, WIDTH, HEIGHT) {\n        this.WIDTH = WIDTH;\n        this.HWIDTH = WIDTH / 2;\n        this.HEIGHT = HEIGHT;\n        this.HHEIGHT = HEIGHT / 2;\n        this._canvas = document.createElement('canvas');\n        this._canvas.width = WIDTH;\n        this._canvas.height = HEIGHT;\n        container.appendChild(this._canvas);\n        this._ctx = this._canvas.getContext('2d');\n        this._backBuffer = this._ctx.createImageData(WIDTH, HEIGHT);\n        const defaultView = geometry_1.I3DXMatrixLookAtLH(matrix_1.I3DXVector3(0.0, 0.0, 10.0), matrix_1.I3DXVector3(0.0, 0.0, 0.0), matrix_1.I3DXVector3(0.0, 1.0, 0.0));\n        const defaultProjection = geometry_1.I3DXMatrixPerspectiveFovLH(matrix_1.I3DXToRadian(45), WIDTH / HEIGHT, 1, 100);\n        this._transforms = {\n            [exports.I3DTS_WORLD]: matrix_1.I3DXMatrixIdentity(4),\n            [exports.I3DTS_VIEW]: defaultView,\n            [exports.I3DTS_PROJECTION]: defaultProjection,\n        };\n        const bufferLength = this.WIDTH * this.HEIGHT;\n        this._zbufferData = new Int32Array(bufferLength);\n        this._zbufferDepth = new Float32Array(bufferLength);\n    }\n    SetTransform(type, matrix) {\n        this._transforms[type] = matrix;\n    }\n    MultiplyTransform(type, matrix) {\n        this._transforms[type] = matrix_1.I3DXMatrixMultiply(matrix, this._transforms[type]);\n    }\n    BeginScene() {\n        this.ZBufferClear();\n        this._backBuffer = this._ctx.createImageData(this.WIDTH, this.HEIGHT);\n    }\n    DrawPrimitive(mode, list) {\n        let transform;\n        transform = matrix_1.I3DXMatrixMultiply(this._transforms[exports.I3DTS_VIEW], this._transforms[exports.I3DTS_WORLD]);\n        transform = matrix_1.I3DXMatrixMultiply(this._transforms[exports.I3DTS_PROJECTION], transform);\n        const screenNormal = matrix_1.I3DXVector3(0, 0, 1);\n        switch (mode) {\n            case exports.I3DPT_POINTLIST:\n                for (let i = 0; i < list.length; i++) {\n                    const f = matrix_1.I3DXMatrixMultiply(transform, list[i].coordinates);\n                    const bx = f.data[0] / f.data[3];\n                    const by = f.data[1] / f.data[3];\n                    const bz = f.data[2] / f.data[3];\n                    // If this is in the field of view\n                    if (Math.abs(bx) <= 1 &&\n                        Math.abs(by) <= 1 &&\n                        Math.abs(bz) <= 1) {\n                        const sx = Math.round((1 - bx) * this.HWIDTH);\n                        const sy = Math.round((1 - by) * this.HHEIGHT);\n                        this.ZBufferSet(sx, sy, list[i].color, bz);\n                    }\n                }\n                break;\n            case exports.I3DPT_LINELIST:\n            case exports.I3DPT_LINESTRIP:\n                for (let i = 0; i < list.length - 1; i++) {\n                    // model space coordinates\n                    const p0 = list[i];\n                    const p1 = list[i + 1];\n                    // These should be points in the perspective space\n                    const f0 = matrix_1.I3DXMatrixMultiply(transform, p0.coordinates);\n                    const f1 = matrix_1.I3DXMatrixMultiply(transform, p1.coordinates);\n                    // convert to the screen\n                    const bx0 = f0.data[0] / f0.data[3];\n                    const by0 = f0.data[1] / f0.data[3];\n                    const bz0 = f0.data[2] / f0.data[3];\n                    const bx1 = f1.data[0] / f1.data[3];\n                    const by1 = f1.data[1] / f1.data[3];\n                    const bz1 = f1.data[2] / f1.data[3];\n                    // Given a distance from 0 to 1 along a line segment\n                    // between point f0 and point f1, return the appropriate\n                    // color.\n                    const [a0, r0, g0, b0] = utils_1.unpack(list[i].color);\n                    const [a1, r1, g1, b1] = utils_1.unpack(list[i + 1].color);\n                    const da = a1 - a0;\n                    const dr = r1 - r0;\n                    const dg = g1 - g0;\n                    const db = b1 - b0;\n                    const color = (distance) => {\n                        return utils_1.pack(Math.round(da * distance + a0), Math.round(dr * distance + r0), Math.round(dg * distance + g0), Math.round(db * distance + b0));\n                    };\n                    // Given a distance from 0 to 1 along a line segment\n                    // between point f0 and point f1, return a 3D, transformed\n                    // position.\n                    const dx = bx1 - bx0;\n                    const dy = by1 - by0;\n                    const dz = bz1 - bz0;\n                    const pos = (distance) => {\n                        return [\n                            dx * distance + bx0,\n                            dy * distance + by0,\n                            dz * distance + bz0,\n                        ];\n                    };\n                    const sx0 = Math.round((1 - bx0) * this.HWIDTH);\n                    const sx1 = Math.round((1 - bx1) * this.HWIDTH);\n                    const dsx = Math.abs(sx1 - sx0);\n                    // console.log(`screen x length: ${sx1} - ${sx0} = ${dsx}`);\n                    for (let j = 0; j <= dsx; j++) {\n                        const dist = j / dsx;\n                        //console.log('line dist:', dist);\n                        const [x, y, z] = pos(dist);\n                        //console.log('xyz', [x, y, z]);\n                        const c = color(dist);\n                        if (Math.abs(x) < 1 &&\n                            Math.abs(y) < 1 &&\n                            Math.abs(z) < 1) {\n                            const sx = Math.round((1 - x) * this.HWIDTH);\n                            const sy = Math.round((1 - y) * this.HHEIGHT);\n                            // console.log(`screen coords ${[sx, sy]}`);\n                            this.ZBufferSet(sx, sy, c, z);\n                        }\n                    }\n                    if (mode === exports.I3DPT_LINELIST) {\n                        // Disconnect the lines by moving along the list\n                        i++;\n                    }\n                }\n                break;\n            case exports.I3DPT_TRIANGLELIST:\n                for (let i = 0; i < list.length - 2; i++) {\n                    const p = matrix_1.I3DXMatrixMultiply(transform, list[i].coordinates);\n                    const q = matrix_1.I3DXMatrixMultiply(transform, list[i + 1].coordinates);\n                    const r = matrix_1.I3DXMatrixMultiply(transform, list[i + 2].coordinates);\n                    const P = matrix_1.I3DXVector3(p.data[0] / p.data[3], p.data[1] / p.data[3], p.data[2] / p.data[3]);\n                    const Q = matrix_1.I3DXVector3(q.data[0] / q.data[3], q.data[1] / q.data[3], q.data[2] / q.data[3]);\n                    const R = matrix_1.I3DXVector3(r.data[0] / r.data[3], r.data[1] / r.data[3], r.data[2] / r.data[3]);\n                    const N = matrix_1.I3DXVectorUnit(matrix_1.I3DXVectorCross(matrix_1.I3DXMatrixSubtract(Q, P), matrix_1.I3DXMatrixSubtract(R, P)));\n                    // the final parameter to the equation of the plane\n                    const d = matrix_1.I3DXVectorDot(screenNormal, P);\n                    const dN = matrix_1.I3DXVectorDot(N, screenNormal);\n                    // if dN === 0, the triangle _should_ be parallel to the ray\n                    if (dN <= 0) {\n                        continue;\n                    }\n                    // Scaled coordinates\n                    const Psx = Math.round((1 - P.data[0]) * this.HWIDTH);\n                    const Psy = Math.round((1 - P.data[1]) * this.HHEIGHT);\n                    const Qsx = Math.round((1 - Q.data[0]) * this.HWIDTH);\n                    const Qsy = Math.round((1 - Q.data[1]) * this.HHEIGHT);\n                    const Rsx = Math.round((1 - R.data[0]) * this.HWIDTH);\n                    const Rsy = Math.round((1 - R.data[1]) * this.HHEIGHT);\n                    // Corners of a boundins square\n                    const Tp = Math.max(Math.min(Psy, Qsy, Rsy), 0);\n                    const Bp = Math.min(Math.max(Psy, Qsy, Rsy), this.HEIGHT);\n                    const Lp = Math.max(Math.min(Psx, Qsx, Rsx), 0);\n                    const Rp = Math.min(Math.max(Psx, Qsx, Rsx), this.WIDTH);\n                    const [Pa] = utils_1.unpack(list[i].color);\n                    const PLab = color_1.ColorToLab(list[i].color);\n                    const [Qa] = utils_1.unpack(list[i + 1].color);\n                    const QLab = color_1.ColorToLab(list[i + 1].color);\n                    const [Ra] = utils_1.unpack(list[i + 2].color);\n                    const RLab = color_1.ColorToLab(list[i + 2].color);\n                    // x and y here are literally pixel coordinates\n                    for (let y = Tp; y <= Bp; y++) {\n                        for (let x = Lp; x <= Rp; x++) {\n                            // Determine if this point within the square is within the triangle\n                            const pq = (y > ((Qsy - Psy) / (Qsx - Psx) * (x - Psx) + Psy));\n                            const pr = (y < ((Rsy - Psy) / (Rsx - Psx) * (x - Psx) + Psy));\n                            const qr = (y > ((Rsy - Qsy) / (Rsx - Qsx) * (x - Qsx) + Qsy));\n                            // Point is on the right side of all 3 lines\n                            if (pq && pr && qr) {\n                                const [Wp, Wq, Wr] = geometry_1.I3DXBarycentricCoords(x, y, Psx, Psy, Qsx, Qsy, Rsx, Rsy);\n                                // convert x and y back to perspective space\n                                const px = 1 - x / this.HWIDTH;\n                                const py = 1 - y / this.HHEIGHT;\n                                const sOrigin = matrix_1.I3DXVector3(px, py, 0);\n                                const z = (d - matrix_1.I3DXVectorDot(N, sOrigin)) / dN;\n                                //const z = P.data[2] * Wp + Q.data[2] * Wq + R.data[2] * Wr;\n                                const L = PLab[0] * Wp + QLab[0] * Wq + RLab[0] * Wr;\n                                const a = PLab[1] * Wp + QLab[1] * Wq + RLab[1] * Wr;\n                                const b = PLab[2] * Wp + QLab[2] * Wq + RLab[2] * Wr;\n                                const [_, vr, vg, vb] = utils_1.unpack(color_1.LabToColor(L, a, b));\n                                const c = utils_1.pack(Math.round(Pa * Wp + Qa * Wq + Ra * Wr), vr, vg, vb);\n                                this.ZBufferSet(x, y, c, z);\n                            }\n                        }\n                    }\n                }\n                break;\n        }\n    }\n    EndScene() {\n        const max = this.WIDTH * this.HEIGHT * 4;\n        for (let i = 0; i < max;) {\n            const [a, r, g, b] = utils_1.unpack(this._zbufferData[i / 4]);\n            this._backBuffer.data[i++] = r;\n            this._backBuffer.data[i++] = g;\n            this._backBuffer.data[i++] = b;\n            this._backBuffer.data[i++] = a;\n        }\n    }\n    Present() {\n        this._ctx.putImageData(this._backBuffer, 0, 0);\n    }\n    ZBufferSet(x, y, color, depth) {\n        //console.log(`setting ${x},${y},${depth} to ${unpack(color)}`);\n        const idx = this.WIDTH * (y - 1) + x;\n        const zdepth = this._zbufferDepth[idx];\n        const zcolor = this._zbufferData[idx];\n        // Current pixel is solid and closer\n        const [za] = utils_1.unpack(zcolor);\n        if (za >= 255 && zdepth < depth) {\n            return;\n        }\n        // New pixel is solid, or no current color\n        const [a] = utils_1.unpack(color);\n        if ((a >= 255 && depth < zdepth) || za === 0) {\n            this._zbufferData[idx] = color;\n            this._zbufferDepth[idx] = depth;\n            return;\n        }\n        // Nothing solid, blend 'em\n        if (depth > zdepth) {\n            this._zbufferData[idx] = color_1.I3DXAlphaBlend(color, zcolor);\n        }\n        else {\n            this._zbufferData[idx] = color_1.I3DXAlphaBlend(zcolor, color);\n        }\n        // Which is closer\n        if (depth < zdepth) {\n            this._zbufferDepth[idx] = depth;\n        }\n    }\n    ZBufferClear() {\n        const bufferLength = this.WIDTH * this.HEIGHT;\n        this._zbufferData = new Int32Array(bufferLength);\n        this._zbufferDepth = new Float32Array(bufferLength);\n    }\n}\nexports.I3DXDevice = I3DXDevice;\n;\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/device.ts?");

/***/ }),

/***/ "./src/indirect3d/geometry.ts":
/*!************************************!*\
  !*** ./src/indirect3d/geometry.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.I3DXBarycentricCoords = exports.I3DXMatrixOrthoLH = exports.I3DXMatrixPerspectiveFovLH = exports.I3DXMatrixLookToLH = exports.I3DXMatrixLookAtLH = exports.I3DXVertex = void 0;\nconst matrix_1 = __webpack_require__(/*! ./matrix */ \"./src/indirect3d/matrix.ts\");\nclass I3DXVertex {\n    constructor(x, y, z, color) {\n        const c = matrix_1.I3DXVector(4, [x, y, z, 1]);\n        this.coordinates = c;\n        this.color = color;\n    }\n}\nexports.I3DXVertex = I3DXVertex;\nfunction I3DXMatrixLookAtLH(pEye, pAt, pUp) {\n    const zaxis = matrix_1.I3DXVectorUnit(matrix_1.I3DXMatrixSubtract(pAt, pEye));\n    const xaxis = matrix_1.I3DXVectorUnit(matrix_1.I3DXVectorCross(pUp, zaxis));\n    const yaxis = matrix_1.I3DXVectorCross(zaxis, xaxis);\n    const xdot = matrix_1.I3DXVectorDot(xaxis, pEye);\n    const ydot = matrix_1.I3DXVectorDot(yaxis, pEye);\n    const zdot = matrix_1.I3DXVectorDot(zaxis, pEye);\n    const matrix = new matrix_1.I3DXMatrix(4, 4, [\n        xaxis.data[0], xaxis.data[1], xaxis.data[2], -xdot,\n        yaxis.data[0], yaxis.data[1], yaxis.data[2], -ydot,\n        zaxis.data[0], zaxis.data[1], zaxis.data[2], -zdot,\n        0, 0, 0, 1,\n    ]);\n    return matrix;\n}\nexports.I3DXMatrixLookAtLH = I3DXMatrixLookAtLH;\nfunction I3DXMatrixLookToLH(pEye, pDir, pUp) {\n    const pAt = matrix_1.I3DXMatrixAdd(pEye, pDir);\n    return I3DXMatrixLookAtLH(pEye, pAt, pUp);\n}\nexports.I3DXMatrixLookToLH = I3DXMatrixLookToLH;\nfunction I3DXMatrixPerspectiveFovLH(fovy, aspect, zn, zf) {\n    const y = 1 / Math.tan(fovy / 2);\n    const x = y / aspect;\n    const zfn = zf / (zf - zn);\n    const matrix = new matrix_1.I3DXMatrix(4, 4, [\n        x, 0, 0, 0,\n        0, y, 0, 0,\n        0, 0, zfn, -zn * zfn,\n        0, 0, 1, 0,\n    ]);\n    return matrix;\n}\nexports.I3DXMatrixPerspectiveFovLH = I3DXMatrixPerspectiveFovLH;\nfunction I3DXMatrixOrthoLH(w, h, zn, zf) {\n    const zfzn = zf - zn;\n    const matrix = new matrix_1.I3DXMatrix(4, 4, [\n        2 / w, 0, 0, 0,\n        0, 2 / h, 0, 0,\n        0, 0, 1 / zfzn, -zn / zfzn,\n        0, 0, 0, 1,\n    ]);\n    return matrix;\n}\nexports.I3DXMatrixOrthoLH = I3DXMatrixOrthoLH;\nfunction I3DXBarycentricCoords(x, y, x1, y1, x2, y2, x3, y3) {\n    const y2y3 = y2 - y3;\n    const x3x2 = x3 - x2;\n    const x1x3 = x1 - x3;\n    const y1y3 = y1 - y3;\n    const y3y1 = y3 - y1;\n    const xx3 = x - x3;\n    const yy3 = y - y3;\n    const d = y2y3 * x1x3 + x3x2 * y1y3;\n    const w1 = (y2y3 * xx3 + x3x2 * yy3) / d;\n    const w2 = (y3y1 * xx3 + x1x3 * yy3) / d;\n    return [w1, w2, 1 - w1 - w2];\n}\nexports.I3DXBarycentricCoords = I3DXBarycentricCoords;\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/geometry.ts?");

/***/ }),

/***/ "./src/indirect3d/index.ts":
/*!*********************************!*\
  !*** ./src/indirect3d/index.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./color */ \"./src/indirect3d/color.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./device */ \"./src/indirect3d/device.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./geometry */ \"./src/indirect3d/geometry.ts\"), exports);\n__exportStar(__webpack_require__(/*! ./matrix */ \"./src/indirect3d/matrix.ts\"), exports);\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/index.ts?");

/***/ }),

/***/ "./src/indirect3d/matrix.ts":
/*!**********************************!*\
  !*** ./src/indirect3d/matrix.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.I3DXVectorUnit = exports.I3DXVectorLength = exports.I3DXVectorDot = exports.I3DXVectorCross = exports.I3DXVector3 = exports.I3DXVector = exports.I3DXMatrixScale = exports.I3DXMatrixSubtract = exports.I3DXMatrixAdd = exports.I3DXMatrixMultiply = exports.I3DXMatrixTranspose = exports.I3DXRotateZMatrix = exports.I3DXRotateYMatrix = exports.I3DXRotateXMatrix = exports.I3DXToRadian = exports.I3DXScaleMatrix = exports.I3DXTranslateMatrix = exports.I3DXMatrixIdentity = exports.I3DXMatrix = void 0;\nclass I3DXMatrix {\n    constructor(rows, cols, data) {\n        if (typeof cols == 'undefined') {\n            cols = rows;\n        }\n        this.rows = rows; // m\n        this.cols = cols; // n\n        if (data) {\n            if (data.length !== rows * cols) {\n                throw new Error(\"data does not match matrix dimension\");\n            }\n            this.data = Float32Array.from(data);\n        }\n        else {\n            this.data = new Float32Array(rows * cols);\n        }\n    }\n    _idx(i, j) {\n        return i * this.cols + j;\n    }\n    get(i, j) {\n        return this.data[this._idx(i, j)];\n    }\n    set(i, j, value) {\n        this.data[this._idx(i, j)] = value;\n    }\n    incr(i, j, value) {\n        this.data[this._idx(i, j)] += value;\n    }\n    debug() {\n        const rows = [];\n        for (let i = 0; i < this.rows; i++) {\n            rows.push([]);\n            for (let j = 0; j < this.cols; j++) {\n                rows[i].push(this.get(i, j));\n            }\n        }\n        console.table(rows);\n    }\n}\nexports.I3DXMatrix = I3DXMatrix;\nfunction I3DXMatrixIdentity(size) {\n    const id = new I3DXMatrix(size, size);\n    for (let i = 0; i < size; i++) {\n        id.set(i, i, 1);\n    }\n    return id;\n}\nexports.I3DXMatrixIdentity = I3DXMatrixIdentity;\nfunction I3DXTranslateMatrix(x, y, z) {\n    const m = I3DXMatrixIdentity(4);\n    m.set(0, 3, x);\n    m.set(1, 3, y);\n    m.set(2, 3, z);\n    return m;\n}\nexports.I3DXTranslateMatrix = I3DXTranslateMatrix;\nfunction I3DXScaleMatrix(sx, sy, sz) {\n    const m = I3DXMatrixIdentity(4);\n    m.set(0, 0, sx);\n    m.set(1, 1, sy);\n    m.set(2, 2, sz);\n    return m;\n}\nexports.I3DXScaleMatrix = I3DXScaleMatrix;\nfunction I3DXToRadian(f) {\n    return (f / 180) * Math.PI;\n}\nexports.I3DXToRadian = I3DXToRadian;\nfunction I3DXRotateXMatrix(theta) {\n    const m = I3DXMatrixIdentity(4);\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    m.set(1, 1, c);\n    m.set(1, 2, -s);\n    m.set(2, 1, s);\n    m.set(2, 2, c);\n    return m;\n}\nexports.I3DXRotateXMatrix = I3DXRotateXMatrix;\nfunction I3DXRotateYMatrix(theta) {\n    const m = I3DXMatrixIdentity(4);\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    m.set(0, 0, c);\n    m.set(0, 2, s);\n    m.set(2, 0, -s);\n    m.set(2, 2, c);\n    return m;\n}\nexports.I3DXRotateYMatrix = I3DXRotateYMatrix;\nfunction I3DXRotateZMatrix(theta) {\n    const m = I3DXMatrixIdentity(4);\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    m.set(0, 0, c);\n    m.set(0, 1, -s);\n    m.set(1, 0, s);\n    m.set(1, 1, c);\n    return m;\n}\nexports.I3DXRotateZMatrix = I3DXRotateZMatrix;\nfunction I3DXMatrixTranspose(A) {\n    const B = new I3DXMatrix(A.cols, A.rows);\n    for (let i = 0; i < A.rows; i++) {\n        for (let j = 0; j < A.cols; j++) {\n            B.set(j, i, A.get(i, j));\n        }\n    }\n    return B;\n}\nexports.I3DXMatrixTranspose = I3DXMatrixTranspose;\nfunction I3DXMatrixMultiply(A, B) {\n    if (A.cols !== B.rows) {\n        const Adim = `(${A.rows},${A.cols})`;\n        const Bdim = `(${B.rows},${B.cols})`;\n        throw new Error(`Matrices must be multiplicable! ${Adim}:${Bdim}`);\n    }\n    const M = new I3DXMatrix(A.rows, B.cols);\n    // Shortcut for 3x3 matrices.\n    if (3 === A.rows && 3 === A.cols && 3 === B.rows && 3 === B.cols) {\n        M.data[0] = A.data[0] * B.data[0] + A.data[1] * B.data[3] + A.data[2] * B.data[6];\n        M.data[1] = A.data[0] * B.data[1] + A.data[1] * B.data[4] + A.data[2] * B.data[7];\n        M.data[2] = A.data[0] * B.data[2] + A.data[1] * B.data[5] + A.data[2] * B.data[8];\n        M.data[3] = A.data[3] * B.data[0] + A.data[4] * B.data[3] + A.data[5] * B.data[6];\n        M.data[4] = A.data[3] * B.data[1] + A.data[4] * B.data[4] + A.data[5] * B.data[7];\n        M.data[5] = A.data[3] * B.data[2] + A.data[4] * B.data[5] + A.data[5] * B.data[8];\n        M.data[6] = A.data[6] * B.data[0] + A.data[7] * B.data[3] + A.data[8] * B.data[6];\n        M.data[7] = A.data[6] * B.data[1] + A.data[7] * B.data[4] + A.data[8] * B.data[7];\n        M.data[8] = A.data[6] * B.data[2] + A.data[7] * B.data[5] + A.data[8] * B.data[8];\n    }\n    // Shortcut for 4x4\n    else if (4 === A.rows && 4 === A.cols && 4 === B.rows && 4 === B.cols) {\n        M.data[0] = A.data[0] * B.data[0] + A.data[1] * B.data[4] + A.data[2] * B.data[8] + A.data[3] * B.data[12];\n        M.data[1] = A.data[0] * B.data[1] + A.data[1] * B.data[5] + A.data[2] * B.data[9] + A.data[3] * B.data[13];\n        M.data[2] = A.data[0] * B.data[2] + A.data[1] * B.data[6] + A.data[2] * B.data[10] + A.data[3] * B.data[14];\n        M.data[3] = A.data[0] * B.data[3] + A.data[1] * B.data[7] + A.data[2] * B.data[11] + A.data[3] * B.data[15];\n        M.data[4] = A.data[4] * B.data[0] + A.data[5] * B.data[4] + A.data[6] * B.data[8] + A.data[7] * B.data[12];\n        M.data[5] = A.data[4] * B.data[1] + A.data[5] * B.data[5] + A.data[6] * B.data[9] + A.data[7] * B.data[13];\n        M.data[6] = A.data[4] * B.data[2] + A.data[5] * B.data[6] + A.data[6] * B.data[10] + A.data[7] * B.data[14];\n        M.data[7] = A.data[4] * B.data[3] + A.data[5] * B.data[7] + A.data[6] * B.data[11] + A.data[7] * B.data[15];\n        M.data[8] = A.data[8] * B.data[0] + A.data[9] * B.data[4] + A.data[10] * B.data[8] + A.data[11] * B.data[12];\n        M.data[9] = A.data[8] * B.data[1] + A.data[9] * B.data[5] + A.data[10] * B.data[9] + A.data[11] * B.data[13];\n        M.data[10] = A.data[8] * B.data[2] + A.data[9] * B.data[6] + A.data[10] * B.data[10] + A.data[11] * B.data[14];\n        M.data[11] = A.data[8] * B.data[3] + A.data[9] * B.data[7] + A.data[10] * B.data[11] + A.data[11] * B.data[15];\n        M.data[12] = A.data[12] * B.data[0] + A.data[13] * B.data[4] + A.data[14] * B.data[8] + A.data[15] * B.data[12];\n        M.data[13] = A.data[12] * B.data[1] + A.data[13] * B.data[5] + A.data[14] * B.data[9] + A.data[15] * B.data[13];\n        M.data[14] = A.data[12] * B.data[2] + A.data[13] * B.data[6] + A.data[14] * B.data[10] + A.data[15] * B.data[14];\n        M.data[15] = A.data[12] * B.data[3] + A.data[13] * B.data[7] + A.data[14] * B.data[11] + A.data[15] * B.data[15];\n    }\n    // Multiply anything.\n    else {\n        for (let i = 0; i < A.rows; i++) {\n            for (let j = 0; j < B.cols; j++) {\n                let t = 0;\n                for (let k = 0; k < A.cols; k++) {\n                    t += A.get(i, k) * B.get(k, j);\n                }\n                M.set(i, j, t);\n            }\n        }\n    }\n    return M;\n}\nexports.I3DXMatrixMultiply = I3DXMatrixMultiply;\nfunction I3DXMatrixAdd(A, B) {\n    if ((A.rows !== B.rows) || (A.cols !== B.cols)) {\n        throw new Error(\"Matrices must be the same size!\");\n    }\n    const M = new I3DXMatrix(A.rows, A.cols);\n    const l = A.rows * A.cols;\n    for (let i = 0; i < l; i++) {\n        M.data[i] = A.data[i] + B.data[i];\n    }\n    return M;\n}\nexports.I3DXMatrixAdd = I3DXMatrixAdd;\nfunction I3DXMatrixSubtract(A, B) {\n    if (A.rows !== B.rows || A.cols !== B.cols) {\n        throw new Error(\"Matrices must be the same size!\");\n    }\n    const M = new I3DXMatrix(A.rows, A.cols);\n    const l = A.rows * A.cols;\n    for (let i = 0; i < l; i++) {\n        M.data[i] = A.data[i] - B.data[i];\n    }\n    return M;\n}\nexports.I3DXMatrixSubtract = I3DXMatrixSubtract;\nfunction I3DXMatrixScale(A, s) {\n    const B = new I3DXMatrix(A.rows, A.cols);\n    const l = A.rows * A.cols;\n    for (let i = 0; i < l; i++) {\n        B.data[i] = A.data[i] * s;\n    }\n    return B;\n}\nexports.I3DXMatrixScale = I3DXMatrixScale;\nfunction I3DXVector(m, data) {\n    return new I3DXMatrix(m, 1, data);\n}\nexports.I3DXVector = I3DXVector;\nfunction I3DXVector3(x, y, z) {\n    const v = I3DXVector(3, [x, y, z]);\n    return v;\n}\nexports.I3DXVector3 = I3DXVector3;\nfunction I3DXVectorCross(a, b) {\n    const c = I3DXVector(3);\n    c.data[0] = a.data[1] * b.data[2] - a.data[2] * b.data[1];\n    c.data[1] = a.data[2] * b.data[0] - a.data[0] * b.data[2];\n    c.data[2] = a.data[0] * b.data[1] - a.data[1] * b.data[0];\n    return c;\n}\nexports.I3DXVectorCross = I3DXVectorCross;\nfunction I3DXVectorDot(a, b) {\n    if (a.rows != b.rows || a.cols != b.cols) {\n        throw new Error(\"Vectors must be the same size!\");\n    }\n    let total = 0;\n    const l = a.rows * a.cols;\n    for (let i = 0; i < l; i++) {\n        total += a.data[i] * b.data[i];\n    }\n    return total;\n}\nexports.I3DXVectorDot = I3DXVectorDot;\nfunction I3DXVectorLength(a) {\n    return Math.sqrt(I3DXVectorDot(a, a));\n}\nexports.I3DXVectorLength = I3DXVectorLength;\nfunction I3DXVectorUnit(a) {\n    return I3DXMatrixScale(a, 1 / I3DXVectorLength(a));\n}\nexports.I3DXVectorUnit = I3DXVectorUnit;\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/matrix.ts?");

/***/ }),

/***/ "./src/indirect3d/utils.ts":
/*!*********************************!*\
  !*** ./src/indirect3d/utils.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sqr = exports.unpack = exports.pack = void 0;\nfunction pack(a, b, c, d) {\n    return (a << 24) | (b << 16) | (c << 8) | d;\n}\nexports.pack = pack;\nfunction unpack(x) {\n    var a = (x & 0xff000000) >>> 24, b = (x & 0x00ff0000) >>> 16, c = (x & 0x0000ff00) >>> 8, d = (x & 0x000000ff);\n    return [a, b, c, d];\n}\nexports.unpack = unpack;\nfunction sqr(i) {\n    return i * i;\n}\nexports.sqr = sqr;\n\n\n//# sourceURL=webpack://indirect3d/./src/indirect3d/utils.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* vim: ts=2 sts=2 sw=2: */\nconst indirect3d_1 = __webpack_require__(/*! ./indirect3d */ \"./src/indirect3d/index.ts\");\n(function main() {\n    const WIDTH = 640, HEIGHT = 480;\n    const container = document.getElementById('indirect-container');\n    const camXInput = document.getElementById('camera-x');\n    const camYInput = document.getElementById('camera-y');\n    const camZInput = document.getElementById('camera-z');\n    const dirXInput = document.getElementById('direction-x');\n    const dirYInput = document.getElementById('direction-y');\n    const dirZInput = document.getElementById('direction-z');\n    const fovyInput = document.getElementById('fovy');\n    const redDepthInput = document.getElementById('red-depth-input');\n    const blueDepthInput = document.getElementById('blue-depth-input');\n    const fixedTriangle = [\n        new indirect3d_1.I3DXVertex(2.5, -3.0, 1.0, indirect3d_1.ARGB(0xff, 0, 0, 0xff)),\n        new indirect3d_1.I3DXVertex(-2.5, -3.0, 1.0, indirect3d_1.ARGB(0xff, 0xff, 0, 0)),\n        new indirect3d_1.I3DXVertex(0.0, 3.0, 1.0, indirect3d_1.ARGB(0xff, 0, 0xff, 0)),\n        new indirect3d_1.I3DXVertex(2.5, -3.0, 1.0, indirect3d_1.ARGB(0xff, 0, 0, 0xff)),\n    ];\n    const movingTriangle = [\n        new indirect3d_1.I3DXVertex(2.5, -3.0, 0, indirect3d_1.ARGB(0x40, 0, 0, 0xff)),\n        new indirect3d_1.I3DXVertex(0.0, 3.0, 0, indirect3d_1.ARGB(0x40, 0, 0, 0xff)),\n        new indirect3d_1.I3DXVertex(-2.5, -3.0, 0, indirect3d_1.ARGB(0x40, 0, 0, 0xff)),\n    ];\n    const id = indirect3d_1.I3DXMatrixIdentity(4);\n    const triLeftFront = [\n        new indirect3d_1.I3DXVertex(0, 0, 0, indirect3d_1.ARGB(0x80, 0, 0, 0xff)),\n        new indirect3d_1.I3DXVertex(3, 3, 0, indirect3d_1.ARGB(0x80, 0, 0, 0xff)),\n        new indirect3d_1.I3DXVertex(6, 0, 0, indirect3d_1.ARGB(0x80, 0, 0, 0xff)),\n    ];\n    const triLeftBack = [\n        new indirect3d_1.I3DXVertex(0, 0, 0, indirect3d_1.XRGB(0xff, 0, 0)),\n        new indirect3d_1.I3DXVertex(3, 3, 0, indirect3d_1.XRGB(0xff, 0, 0)),\n        new indirect3d_1.I3DXVertex(6, 0, 0, indirect3d_1.XRGB(0xff, 0, 0)),\n    ];\n    const matView = indirect3d_1.I3DXMatrixLookToLH(indirect3d_1.I3DXVector3(camXInput.valueAsNumber, camYInput.valueAsNumber, camZInput.valueAsNumber), // the camera position\n    indirect3d_1.I3DXVector3(dirXInput.valueAsNumber, dirYInput.valueAsNumber, dirZInput.valueAsNumber), // the \"look-to\" direction\n    indirect3d_1.I3DXVector3(0, 1, 0));\n    const matProj = indirect3d_1.I3DXMatrixPerspectiveFovLH(indirect3d_1.I3DXToRadian(fovyInput.valueAsNumber), // the horizontal field of view\n    WIDTH / HEIGHT, // aspect ratio\n    1.0, // near view-plane\n    100.0);\n    let i3d = new indirect3d_1.I3DXDevice(container, WIDTH, HEIGHT);\n    let idx = 0;\n    i3d.SetTransform(indirect3d_1.I3DTS_VIEW, matView);\n    //i3d.SetTransform(I3DTS_PROJECTION, matProj);\n    i3d.SetTransform(indirect3d_1.I3DTS_PROJECTION, matProj);\n    i3d.SetTransform(indirect3d_1.I3DTS_WORLD, id);\n    let isPlaying = false;\n    let lastFrameEnd;\n    function play() {\n        //console.time('frame');\n        i3d.BeginScene();\n        const matView = indirect3d_1.I3DXMatrixLookToLH(indirect3d_1.I3DXVector3(camXInput.valueAsNumber, camYInput.valueAsNumber, camZInput.valueAsNumber), // the camera position\n        indirect3d_1.I3DXVector3(dirXInput.valueAsNumber, dirYInput.valueAsNumber, dirZInput.valueAsNumber), // the \"look-to\" direction\n        indirect3d_1.I3DXVector3(0, 1, 0));\n        const matProj = indirect3d_1.I3DXMatrixPerspectiveFovLH(indirect3d_1.I3DXToRadian(fovyInput.valueAsNumber), // the horizontal field of view\n        WIDTH / HEIGHT, // aspect ratio\n        1.0, // near view-plane\n        100.0);\n        i3d.SetTransform(indirect3d_1.I3DTS_VIEW, matView);\n        i3d.SetTransform(indirect3d_1.I3DTS_PROJECTION, matProj);\n        i3d.SetTransform(indirect3d_1.I3DTS_WORLD, id);\n        const blueDepth = blueDepthInput.valueAsNumber;\n        const blueTransform = indirect3d_1.I3DXTranslateMatrix(-9, 2, blueDepth);\n        i3d.SetTransform(indirect3d_1.I3DTS_WORLD, blueTransform);\n        i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLELIST, triLeftFront);\n        const redDepth = redDepthInput.valueAsNumber;\n        const redTransform = indirect3d_1.I3DXTranslateMatrix(-9, 2, redDepth);\n        i3d.SetTransform(indirect3d_1.I3DTS_WORLD, redTransform);\n        i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLELIST, triLeftBack);\n        const rot = indirect3d_1.I3DXRotateYMatrix(idx);\n        i3d.SetTransform(indirect3d_1.I3DTS_WORLD, rot);\n        i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLELIST, movingTriangle);\n        const left = indirect3d_1.I3DXTranslateMatrix(0, 0, Math.sin(idx / 2));\n        i3d.SetTransform(indirect3d_1.I3DTS_WORLD, left);\n        i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLELIST, fixedTriangle);\n        i3d.EndScene();\n        i3d.Present();\n        //console.timeEnd('frame');\n        const now = Date.now();\n        const dt = now - lastFrameEnd;\n        idx += 0.005 * dt;\n        if (isPlaying) {\n            requestAnimationFrame(play);\n        }\n        lastFrameEnd = now;\n    }\n    window.addEventListener('keyup', function (e) {\n        if (e.keyCode == 27) { // Escape\n            isPlaying = false;\n            console.log(\"Stop animation.\");\n        }\n        else if (e.keyCode == 13) {\n            isPlaying = true;\n            lastFrameEnd = Date.now();\n            console.log(\"Start animation.\");\n            requestAnimationFrame(play);\n        }\n        e.preventDefault();\n        return false;\n    }, true);\n    console.log(\"Construct scene\", new Date());\n    i3d.BeginScene();\n    //i3d.DrawPrimitive(I3DPT_TRIANGLELIST, fixedTriangle);\n    const blueDepth = blueDepthInput.valueAsNumber;\n    const blueTransform = indirect3d_1.I3DXTranslateMatrix(-9, 2, blueDepth);\n    i3d.SetTransform(indirect3d_1.I3DTS_WORLD, blueTransform);\n    i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLELIST, triLeftFront);\n    const redDepth = redDepthInput.valueAsNumber;\n    const redTransform = indirect3d_1.I3DXTranslateMatrix(-9, 2, redDepth);\n    i3d.SetTransform(indirect3d_1.I3DTS_WORLD, redTransform);\n    i3d.DrawPrimitive(indirect3d_1.I3DPT_TRIANGLELIST, triLeftBack);\n    i3d.EndScene();\n    i3d.Present();\n    console.log(\"End Construct scene\", new Date());\n})();\n\n\n//# sourceURL=webpack://indirect3d/./src/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;